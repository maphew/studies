<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="lkj.20190915145700.1"><vh>Pyshortcuts</vh>
<v t="lkj.20190915145700.2"><vh>@path ../pyshortcuts</vh>
<v t="lkj.20190915160022.13"><vh>.travis.yml</vh></v>
<v t="lkj.20190915160022.10"><vh>/doc/</vh></v>
<v t="lkj.20190915160022.9"><vh>/examples/</vh></v>
<v t="lkj.20190915160022.7"><vh>/pyshortcuts/</vh>
<v t="lkj.20190915160127.9"><vh>/icons/</vh></v>
<v t="lkj.20190915160127.8"><vh>@clean __init__.py</vh>
<v t="lkj.20190915160228.1"><vh>Declarations (__init__.py)</vh></v>
<v t="lkj.20190915160228.2"><vh>shortcut_cli (__init__.py)</vh></v>
</v>
<v t="lkj.20190915160127.7"><vh>@clean darwin.py</vh>
<v t="lkj.20190915160314.1"><vh>Declarations (darwin.py)</vh></v>
<v t="lkj.20190915160314.2"><vh>fix_anacondapy_pythonw (darwin.py)</vh></v>
<v t="lkj.20190915160314.3"><vh>get_folders (darwin.py)</vh></v>
<v t="lkj.20190915160314.4"><vh>make_shortcut (darwin.py)</vh></v>
</v>
<v t="lkj.20190915160127.6"><vh>@clean linux.py</vh>
<v t="lkj.20190915160354.1"><vh>Declarations (linux.py)</vh></v>
<v t="lkj.20190915160354.2"><vh>get_folders (linux.py)</vh></v>
<v t="lkj.20190915160354.3"><vh>get_linux_desktop (linux.py)</vh></v>
<v t="lkj.20190915160354.4"><vh>get_linux_menu (linux.py)</vh></v>
<v t="lkj.20190915160354.5"><vh>make_shortcut (linux.py)</vh></v>
</v>
<v t="lkj.20190915160127.5"><vh>@clean shortcut.py</vh>
<v t="lkj.20190915160358.1"><vh>Declarations (shortcut.py)</vh></v>
<v t="lkj.20190915160358.2"><vh>fix_filename (shortcut.py)</vh></v>
<v t="lkj.20190915160358.3"><vh>class Shortcut</vh>
<v t="lkj.20190915160358.4"><vh>Shortcut.__init__</vh></v>
</v>
</v>
<v t="lkj.20190915160127.3"><vh>@clean utils.py</vh>
<v t="lkj.20190915160400.1"><vh>Declarations (utils.py)</vh></v>
<v t="lkj.20190915160400.2"><vh>unixpath (utils.py)</vh></v>
<v t="lkj.20190915160400.3"><vh>winpath (utils.py)</vh></v>
<v t="lkj.20190915160400.4"><vh>get_homedir (utils.py)</vh></v>
<v t="lkj.20190915160400.5"><vh>fix_paths (utils.py)</vh></v>
</v>
<v t="lkj.20190915160127.2"><vh>@clean windows.py</vh>
<v t="lkj.20190915160403.1"><vh>Declarations (windows.py)</vh></v>
<v t="lkj.20190915160403.2"><vh>get_exe_types (windows.py)</vh></v>
<v t="lkj.20190915160403.3"><vh>old get_folders (windows.py)</vh></v>
<v t="lkj.20190919214201.1"><vh>get_folders (windows.py)</vh></v>
<v t="lkj.20190915160403.4"><vh>make_shortcut (windows.py)</vh></v>
</v>
<v t="lkj.20190915160127.1"><vh>@clean wxgui.py</vh>
<v t="lkj.20190915160407.1"><vh>Declarations (wxgui.py)</vh></v>
<v t="lkj.20190915160407.2"><vh>class ShortcutFrame(wx.Frame)</vh>
<v t="lkj.20190915160407.3"><vh>ShortcutFrame(wx.Frame).__init__</vh></v>
<v t="lkj.20190915160407.4"><vh>ShortcutFrame(wx.Frame).onBrowseScript</vh></v>
<v t="lkj.20190915160407.5"><vh>ShortcutFrame(wx.Frame).onBrowseIcon</vh></v>
<v t="lkj.20190915160407.6"><vh>ShortcutFrame(wx.Frame).onBrowseFolder</vh></v>
<v t="lkj.20190915160407.7"><vh>ShortcutFrame(wx.Frame).onScriptEnter</vh></v>
<v t="lkj.20190915160407.8"><vh>ShortcutFrame(wx.Frame).onNameEnter</vh></v>
<v t="lkj.20190915160407.9"><vh>ShortcutFrame(wx.Frame).make_Shortcut</vh></v>
<v t="lkj.20190915160407.10"><vh>ShortcutFrame(wx.Frame).onCreate</vh></v>
<v t="lkj.20190915160407.11"><vh>ShortcutFrame(wx.Frame).onSavePy</vh></v>
<v t="lkj.20190915160407.12"><vh>ShortcutFrame(wx.Frame).onAbout</vh></v>
<v t="lkj.20190915160407.13"><vh>ShortcutFrame(wx.Frame).onExit</vh></v>
</v>
</v>
</v>
<v t="lkj.20190915160022.6"><vh>/tests/</vh></v>
<v t="lkj.20190915160022.3"><vh>README.md</vh></v>
<v t="lkj.20190915160022.2"><vh>appveyor.yml</vh></v>
<v t="lkj.20190915160022.1"><vh>setup.py</vh></v>
</v>
</v>
<v t="lkj.20190915160149.1"><vh>working on</vh>
<v t="lkj.20190915160228.1"></v>
<v t="lkj.20190919214201.1"></v>
<v t="lkj.20190915160754.1"><vh>shortcut.py - filtered</vh>
<v t="lkj.20190915160358.1"></v>
<v t="lkj.20190915160358.3"></v>
</v>
</v>
<v t="lkj.20190919213126.1"><vh>Found:make_shortcut</vh>
<v t="lkj.20190915160228.1"></v>
<v t="lkj.20190915160314.4"></v>
<v t="lkj.20190915160354.5"></v>
<v t="lkj.20190915160403.4"></v>
</v>
<v t="lkj.20190919213421.1"><vh>Found:homedir</vh>
<v t="lkj.20190915160354.1"></v>
<v t="lkj.20190915160358.1"></v>
<v t="lkj.20190915160403.1"></v>
<v t="lkj.20190915160400.4"></v>
<v t="lkj.20190915160354.5"></v>
<v t="lkj.20190915160403.4"></v>
<v t="lkj.20190915160358.4"></v>
<v t="lkj.20190915160400.3"></v>
</v>
<v t="lkj.20190919235058.1"><vh>Found:f'</vh>
<v t="lkj.20190915160403.4"></v>
<v t="lkj.20190915160358.4"></v>
<v t="lkj.20190915160228.2"></v>
</v>
</vnodes>
<tnodes>
<t tx="lkj.20190915145700.1">Easy cross-platform creation of shortcuts supporting virtual and Anaconda environments

Upstream: https://github.com/newville/pyshortcuts
My fork: https://github.com/maphew/pyshortcuts.git


@path ../pyshortcuts
</t>
<t tx="lkj.20190915145700.2"></t>
<t tx="lkj.20190915160022.1"></t>
<t tx="lkj.20190915160022.10">@path doc</t>
<t tx="lkj.20190915160022.13"></t>
<t tx="lkj.20190915160022.2"></t>
<t tx="lkj.20190915160022.3"></t>
<t tx="lkj.20190915160022.6">@path tests</t>
<t tx="lkj.20190915160022.7">@path pyshortcuts</t>
<t tx="lkj.20190915160022.9">@path examples</t>
<t tx="lkj.20190915160127.1">@others
@language python
@tabwidth -4
</t>
<t tx="lkj.20190915160127.2">#!/usr/bin/env python
@others
@language python
@tabwidth -4
</t>
<t tx="lkj.20190915160127.3">#!/usr/bin/env python
@others
@language python
@tabwidth -4
</t>
<t tx="lkj.20190915160127.5">#!/usr/bin/env python
@others
@language python
@tabwidth -4
</t>
<t tx="lkj.20190915160127.6">#!/usr/bin/env python
@others
@language python
@tabwidth -4
</t>
<t tx="lkj.20190915160127.7">#!/usr/bin/env python
@others
@language python
@tabwidth -4
</t>
<t tx="lkj.20190915160127.8">#!/usr/bin/env python

@others
@language python
@tabwidth -4
</t>
<t tx="lkj.20190915160127.9">@path icons</t>
<t tx="lkj.20190915160149.1">@language python
@tabwidth -4
</t>
<t tx="lkj.20190915160228.1">__version__ = '1.4'

import os
import sys
from optparse import OptionParser

from .utils import platform

make_shortcut = None
if platform.startswith('win'):
    from .windows import make_shortcut, get_folders

elif platform.startswith('darwin'):
    from .darwin import make_shortcut

elif platform.startswith('linux'):
    from .linux import make_shortcut, get_folders

try:
    import wx
    from .wxgui import ShortcutFrame
    HAS_WX = True
except ImportError:
    HAS_WX = False

</t>
<t tx="lkj.20190915160228.2">def shortcut_cli():
    '''
    command-line interface to creating desktop shortcuts
    '''
    usage = 'Usage: pyshortcut [options] scriptname'
    vers = 'pyshortcut %s' % (__version__)

    parser = OptionParser(usage=usage, prog='pyshortcut', version=vers)

    parser.add_option('-n', '--name', dest='name', metavar='link_name',
                      default=None, help='name for shortcut link')

    parser.add_option('-i', '--icon', dest='icon', metavar='icon_name',
                      default=None, help='name of icon file')

    parser.add_option('-f', '--folder', dest='folder', metavar='subfolder',
                      default=None, help='subfolder on desktop to put icon')

    parser.add_option('-t', '--terminal', dest='terminal', action='store_true',
                      default=True, help='run in a Terminal [True]')

    parser.add_option('-g', '--gui', dest='gui', action='store_true',
                      default=False, help='run as GUI, with no Terminal [False]')

    parser.add_option('-w', '--wxgui', dest='wxgui', action='store_true',
                      default=False, help='run GUI version of pyshortcut')

    (options, args) = parser.parse_args()

    if HAS_WX and options.wxgui:
        app = wx.App()
        ShortcutFrame().Show(True)
        app.MainLoop()
        sys.exit()

    if options.gui:
        options.terminal = False

    if len(args) != 1:
        print("pyshortcut: must provide script.  try 'pyshortcuts -h'")
        sys.exit()

    desc = scriptname = args[0]
    print('creating %s shortcut for script %s' % (platform, scriptname))
    scut = make_shortcut(scriptname, name=options.name, description=desc,
                         terminal=options.terminal, folder=options.folder,
                         icon=options.icon)
    return scut
</t>
<t tx="lkj.20190915160314.1">"""
Create desktop shortcuts for Darwin / MacOS
"""
from __future__ import print_function
import os
import sys
import shutil

from .shortcut import Shortcut

</t>
<t tx="lkj.20190915160314.2">def fix_anacondapy_pythonw(fname):
    """fix shebang line for scripts using anaconda python
    to use 'pythonw' instead of 'python'
    """
    # print(" fix anaconda py (%s) for %s" % (sys.prefix, script))
    with open(fname, 'r') as fh:
        try:
            lines = fh.readlines()
        except IOError:
            lines = ['-']
    firstline = lines[0][:-1].strip()
    if firstline.startswith('#!') and 'python' in firstline:
        firstline = '#!/usr/bin/env pythonw'
        fh = open(fname, 'w')
        fh.write('%s\n' % firstline)
        fh.write("".join(lines[1:]))
        fh.close()
</t>
<t tx="lkj.20190915160314.3">
</t>
<t tx="lkj.20190915160314.4">def make_shortcut(script, name=None, description=None, terminal=True,
                  folder=None, icon=None):
    """create minimal Mac App to run script

    Arguments
    ---------
    script      (str)  path to script to run.  This can include  command-line arguments
    name        (str or None) name to use for shortcut [defaults to script name]
    description (str or None) longer description of script [defaults to `name`]
    icon        (str or None) path to icon file [defaults to python icon]
    folder      (str or None) folder on Desktop to put shortcut [defaults to Desktop]
    terminal    (True or False) whether to run in a Terminal  [True]
    """
    scut = Shortcut(script, name=name, description=description, folder=folder, icon=icon)

    osascript = '%s %s' % (scut.full_script, scut.args)
    osascript = osascript.replace(' ', '\\ ')

    pyexe = sys.executable
    has_conda = os.path.exists(os.path.join(sys.prefix, 'conda-meta'))
    pyapp_exe = "{prefix:s}/python.app/Contents/MacOS/python".format(prefix=sys.prefix)
    if has_conda and os.path.exists(pyapp_exe):
        pyexe = pyapp_exe
        fix_anacondapy_pythonw(scut.full_script)

    dest = scut.target
    if os.path.exists(dest):
        shutil.rmtree(dest)
    os.mkdir(dest)
    os.mkdir(os.path.join(dest, 'Contents'))
    os.mkdir(os.path.join(dest, 'Contents', 'MacOS'))
    os.mkdir(os.path.join(dest, 'Contents', 'Resources'))
    opts = dict(name=scut.name,
                desc=scut.description,
                script=scut.full_script,
                args=scut.args,
                prefix=sys.prefix,
                pyexe=pyexe,
                osascript=osascript)

    info = """&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN"
"http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
  &lt;dict&gt;
  &lt;key&gt;CFBundleGetInfoString&lt;/key&gt; &lt;string&gt;{desc:s}&lt;/string&gt;
  &lt;key&gt;CFBundleName&lt;/key&gt; &lt;string&gt;{name:s}&lt;/string&gt;
  &lt;key&gt;CFBundleExecutable&lt;/key&gt; &lt;string&gt;{name:s}&lt;/string&gt;
  &lt;key&gt;CFBundleIconFile&lt;/key&gt; &lt;string&gt;{name:s}&lt;/string&gt;
  &lt;key&gt;CFBundlePackageType&lt;/key&gt; &lt;string&gt;APPL&lt;/string&gt;
  &lt;/dict&gt;
&lt;/plist&gt;
"""

    header = """#!/bin/bash
## Run script with Python that created this script
export PYTHONEXECUTABLE={prefix:s}/bin/python
export PY={pyexe:s}
export SCRIPT={script:s}
export ARGS='{args:s}'
"""
    text = "$PY $SCRIPT $ARGS"
    if terminal:
        text = """
osascript -e 'tell application "Terminal"
   do script "'${{PY}}\ {osascript:s}'"
end tell
'
"""

    with open(os.path.join(dest, 'Contents', 'Info.plist'), 'w') as fout:
        fout.write(info.format(**opts))

    ascript_name = os.path.join(dest, 'Contents', 'MacOS', scut.name)
    with open(ascript_name, 'w') as fout:
        fout.write(header.format(**opts))
        fout.write(text.format(**opts))
        fout.write("\n")

    os.chmod(ascript_name, 493) ## = octal 755 / rwxr-xr-x
    icon_dest = os.path.join(dest, 'Contents', 'Resources', scut.name + '.icns')
    shutil.copy(scut.icon, icon_dest)

    return scut
</t>
<t tx="lkj.20190915160354.1">"""
Create desktop shortcuts for Linux
"""
from __future__ import print_function
import os
import sys
from collections import namedtuple


from .shortcut import Shortcut
from .utils import get_homedir

DESKTOP_FORM = """[Desktop Entry]
Name={name:s}
Type=Application
Comment={desc:s}
Terminal={term:s}
Icon={icon:s}
Exec={exe:s} {script:s} {args:s}
"""

def get_folders():
    """Return named tuple of Home, Desktop and Startmenu paths.

        folders = get_folders()
        print("Home, Desktop, StartMenu ",
            folders.home, folders.desktop, folders.startmenu)
    """
    homedir = get_homedir()
    desktop = os.path.join(homedir, 'Desktop')

    # search for .config/user-dirs.dirs in HOMEDIR
    ud_file = os.path.join(homedir, '.config', 'user-dirs.dirs')
    if os.path.exists(ud_file):
        val = desktop
        with open(ud_file, 'r') as fh:
            text = fh.readlines()
        for line in text:
            if 'DESKTOP' in line:
                line = line.replace('$HOME', homedir)[:-1]
                key, val = line.split('=')
                val = val.replace('"', '').replace("'", "")
        desktop = val

    nt = namedtuple("folders", "home desktop startmenu")
    folders = nt(
        homedir,
        desktop,
        None
    )
    return folders
</t>
<t tx="lkj.20190915160354.2"></t>
<t tx="lkj.20190915160354.3"></t>
<t tx="lkj.20190915160354.4">

</t>
<t tx="lkj.20190915160354.5">def make_shortcut(script, name=None, description=None, terminal=True,
                  folder=None, icon=None):
    """create linux .desktop file

    Arguments
    ---------
    script      (str)  path to script to run.  This can include  command-line arguments
    name        (str or None) name to use for shortcut [defaults to script name]
    description (str or None) longer description of script [defaults to `name`]
    icon        (str or None) path to icon file [defaults to python icon]
    folder      (str or None) folder on Desktop to put shortcut [defaults to Desktop]
    terminal    (True or False) whether to run in a Terminal  [True]
    """

    scut = Shortcut(script, name=name, description=description, folder=folder, icon=icon)

    term = 'false'
    if terminal:
        term = 'true'

    text = DESKTOP_FORM.format(name=scut.name, desc=scut.description,
                               exe=sys.executable, icon=scut.icon,
                               script=scut.full_script, args=scut.args,
                               term=term)
    # Desktop
    desktop = os.path.join(get_homedir(), 'Desktop') # todo: use folders.desktop
    if os.path.exists(desktop):
        with open(scut.target, 'w') as fout:
            fout.write(text)

    # Local Applications
    appfolder = os.path.join(get_homedir(), '.local', 'share', 'applications')
    if os.path.exists(appfolder):
        _, target = os.path.split(scut.target)
        apptarget = os.path.join(appfolder, target)
        with open(apptarget, 'w') as fout:
            fout.write(text)

    return scut
</t>
<t tx="lkj.20190915160358.1">from __future__ import print_function
import os
import sys
from .utils import platform, get_homedir

import six

if six.PY3:
    maketrans = str.maketrans
else:
    from string import maketrans

BAD_FILECHARS = ';~,`!%$@$&amp;^?*#:"/|\'\\\t\r\n(){}[]&lt;&gt;'
GOOD_FILECHARS = '_'*len(BAD_FILECHARS)

</t>
<t tx="lkj.20190915160358.2">def fix_filename(s):
    """
    fix string to be a 'good' filename, with very few special
    characters and no more than 1 '.'.

    More restrictive than most OSes, but avoids nasty cases.
    """
    t = str(s).translate(maketrans(BAD_FILECHARS, GOOD_FILECHARS))
    if t.count('.') &gt; 1:
        for i in range(t.count('.') - 1):
            idot = t.find('.')
            t = "%s_%s" % (t[:idot], t[idot+1:])
    return t

</t>
<t tx="lkj.20190915160358.3">class Shortcut():
    """
    representation of a Shortcuts parameters.

    Arguments:
      script        script to run including optional arguments
      name          name for shortcut (`None` to use name of script file)
      description   shortcut long description (`None` to use name of script file)
      folder        folder under Desktop to place shortcut (`None` for on Desktop)
      icon          name of icon file (full path) for shortcut (`None` for default)

    Contains:
      name          name for shortcut
      script        name of python script to be run
      full_script   full name of python script to be run
      args          command line arguments
      target        full name of shortcut to create
      icon          full name of icon to use
    """
    @others
</t>
<t tx="lkj.20190915160358.4">def __init__(self, script, name=None, description=None,
             folder=None, icon=None):

    words = script.split(' ', 1)
    if len(words) &lt; 2:
        words.append('')
    self.script = words[0]
    self.args = words[1]
    self.full_script = os.path.abspath(self.script)

    if name is None:
        name = self.script

    _, name = os.path.split(name)
    name = fix_filename(name)
    if name.endswith('.py'):
        name = name[:-3]

    self.name = name
    self.description = description
    if self.description is None:
        self.description = name

    # desktop = dest = os.path.join(get_homedir(), 'Desktop')
    # if folder is not None:
    #     # if folder var has a value
    #     #   and it matches the beginning of just created `desktop` var
    #     #   reassign folder var to be substring of folder var
    #     #   that is 1 char longer that desktop var
    #     # reassign `dest` to be desktop path + folder path
    #     if folder.startswith(desktop):
    #         folder = folder[len(desktop)+1:]
    #     dest = os.path.join(desktop, folder)

    #ignore all above, just make dest same as folder:
    desktop = dest = folder
    # print(f'---target dest: {dest}') # debug, py36+

    if not os.path.exists(dest):
        os.mkdir(dest)

    suffix = {'linux': 'desktop', 'darwin': 'app', 'win': 'lnk'}[platform]
    self.target = os.path.join(dest, '%s.%s' % (name, suffix))
    self.folder = dest[len(desktop)+1:]

    self.icon = icon
    if self.icon is None:
        _path, _fname = os.path.split(__file__)
        _path = os.path.join(_path, 'icons')
        suffix = 'ico'
        if platform.startswith('darwin'):
            suffix = 'icns'
        self.icon = os.path.join(_path, 'py.%s' % (suffix))

    self.icon = os.path.abspath(self.icon)
</t>
<t tx="lkj.20190915160400.1">"""
utilities for pyshortcuts
  get_homedir()         get home directory (all platforms)
  get_win_folders()     get Home, Desktop and Startmenu paths
  fix_paths()           get absolute paths for script, target folder, icon
"""
import os
import sys
from collections import namedtuple


platform = sys.platform
if os.name == "nt":
    platform = "win"
if platform == "linux2":
    platform = "linux"


</t>
<t tx="lkj.20190915160400.2">def unixpath(d):
    "unix path"
    return d.replace("\\", "/")


</t>
<t tx="lkj.20190915160400.3">def winpath(d):
    "ensure path uses windows delimiters"
    if d.startswith("//"):
        d = d[1:]
    d = d.replace("/", "\\")
    return d


nativepath = unixpath
if platform == "win":
    nativepath = winpath

HAS_PWD = True
try:
    import pwd
except ImportError:
    HAS_PWD = False

## WIP: unix folder paths
def get_nix_folders():
    """Return named tuple of Home, Desktop and StartMenu paths.

        folders = get_nix_folders()
        print("Home, Desktop, StartMenu ",
            folders.home, folders.desktop, folders.startmenu)
    """
    nt = namedtuple("folders", "home desktop startmenu")
    folders = nt(get_homedir(),
                os.path.join(get_homedir(), "Desktop"),
                None)
    return folders

##


def get_win_folders():
    """Return named tuple of Home, Desktop and Startmenu paths.

        folders = get_win_folders()
        print("Home, Desktop, StartMenu ",
            folders.home, folders.desktop, folders.startmenu)
    """
    import win32com.client

    shellapp = win32com.client.Dispatch("Shell.Application")

    nt = namedtuple("folders", "home desktop startmenu")
    folders = nt(
        shellapp.namespace(40).self.path,
        shellapp.namespace(11).self.path,
        shellapp.namespace(0).self.path,
    )
    return folders
    # Windows Special Folders
    # ID numbers from https://gist.github.com/maphew/47e67b6a99e240f01aced8b6b5678eeb
    # https://docs.microsoft.com/en-gb/windows/win32/api/shldisp/ne-shldisp-shellspecialfolderconstants#constants
    #
    # Start menu: user = 11, all users = 22
    # Desktop   : user =  0, all users = 25
    # Profile   : = 40, same as %USERPROFILE%


</t>
<t tx="lkj.20190915160400.4">def get_homedir():
    "determine home directory of current user"
    home = None

    def get_home_from_env():
        # try '~' which works on most Unixes, then common environmental variables
        for var in ("~", "$HOME", "$HOMEPATH", "$USERPROFILE", "$ALLUSERSPROFILE"):
            p = os.path.expandvars(var)
            if os.path.exists(p):
                return p

    # for Unixes, allow for sudo case
    susername = os.environ.get("SUDO_USER", None)
    if HAS_PWD and susername is not None and home is None:
        home = pwd.getpwnam(susername).pw_dir

    elif home is None:
        home = get_home_from_env()

    # finally, use current folder
    else:
        home = os.path.abspath(".")

    return nativepath(home)


</t>
<t tx="lkj.20190915160400.5">def fix_paths(script, folder=None, icon_path=None, icon=None):
    """get absolute paths to

    1.  script
    2.  desktop folder or subfolder (creating if needed)
    3.  icon

    """
    scriptname = os.path.abspath(script)

    dest = os.path.join(get_homedir(), "Desktop")
    if folder is not None:
        dest = os.path.join(dest, folder)
        if not os.path.exists(dest):
            os.mkdir(dest)

    if icon_path is None:
        _path, _fname = os.path.split(__file__)
        icon_path = os.path.join(_path, "icons")
    if icon is None:
        icon = "py"
    ext = ".ico"
    if platform.startswith("darwin"):
        ext = ".icns"
    iconfile = os.path.abspath(os.path.join(icon_path, icon + ext))

    return scriptname, dest, iconfile
</t>
<t tx="lkj.20190915160403.1">"""
Create desktop shortcuts for Windows
"""
from __future__ import print_function
import os
import sys

from .utils import get_homedir
from .shortcut import Shortcut

import win32com.client
shellapp = win32com.client.Dispatch("Shell.Application")
objshell = win32com.client.Dispatch("Wscript.Shell")


</t>
<t tx="lkj.20190915160403.2">def get_exe_types():
    '''Return list of valid executable file extensions [.com, .exe, ...]'''
    exetypes = [ext.lower() for ext in os.environ['PATHEXT'].split(os.pathsep)]
    return exetypes

</t>
<t tx="lkj.20190915160403.3"># Windows Special Folders
# ID numbers from https://gist.github.com/maphew/47e67b6a99e240f01aced8b6b5678eeb
# https://docs.microsoft.com/en-gb/windows/win32/api/shldisp/ne-shldisp-shellspecialfolderconstants#constants
#
# Start menu: user = 11, all users = 22
# Desktop   : user =  0, all users = 25
#
def get_menu_folder():
    '''Return user Start Menu folder'''
    return shellapp.namespace(11).self.path
def get_desktop_folder():
    '''Return user Desktop folder'''
    return shellapp.namespace(0).self.path


</t>
<t tx="lkj.20190915160403.4">def make_shortcut(script, name=None, description=None, terminal=True,
                  folder=None, icon=None):
    """create windows shortcut

    Arguments
    ---------
    script      (str)  path to script to run.  This can include  command-line arguments
    name        (str or None) name to use for shortcut [defaults to script name]
    description (str or None) longer description of script [defaults to `name`]
    icon        (str or None) path to icon file [defaults to python icon]
    folder      (str or None) folder on Desktop to put shortcut [defaults to Desktop]
    terminal    (True or False) whether to run in a Terminal  [True]
    """
    homedir = get_homedir()
    # print(f'--- windows.py:make_shortcut() folder= {folder}') # debug, py36+

    scut = Shortcut(script, name=name, description=description,
                    folder=folder, icon=icon)

    pyexe = os.path.join(sys.prefix, 'pythonw.exe')
    if terminal:
        pyexe = os.path.join(sys.prefix, 'python.exe')

    # Check for other valid ways to run the script
    # try appending .exe if script itself not found
    if not os.path.exists(scut.full_script):
        tname = scut.full_script + '.exe'
        if os.path.exists(tname):
            pyexe = tname
            scut.full_script = ''

    # If script is already executable use it directly instead of via pyexe
    ext = os.path.splitext(scut.full_script)[1].lower()
    if  ext in get_exe_types():
        pyexe = scut.full_script
        scut.full_script = ''

    wscript = objshell.CreateShortCut(scut.target)
    wscript.Targetpath = '"%s"' % pyexe
    wscript.Arguments = '%s %s' % (scut.full_script, scut.args)
    wscript.WorkingDirectory = homedir
    wscript.WindowStyle = 0
    wscript.Description = scut.description
    wscript.IconLocation = scut.icon
    wscript.save()

    return scut
</t>
<t tx="lkj.20190915160407.1">import time
import os
import sys
import wx

is_wxPhoenix = 'phoenix' in wx.PlatformInfo
if is_wxPhoenix:
    PyDeadObjectError = RuntimeError
else:
    from wx._core import PyDeadObjectError

import wx.lib.filebrowsebutton as filebrowse

from pyshortcuts import make_shortcut
from pyshortcuts.shortcut import Shortcut, fix_filename
from pyshortcuts.utils import platform, get_homedir

PY_FILES = "Python scripts (*.py)|*.py"
ALL_FILES = "All files (*.*)|*.*"
ICO_FILES = "Icon files (*.ico)|*.ico"
ICNS_FILES = "Mac Icon files (*.icns)|*.icns"

CEN = wx.ALIGN_CENTER|wx.ALIGN_CENTER_VERTICAL
LEFT = wx.ALIGN_LEFT|wx.ALIGN_CENTER_VERTICAL
RIGHT = wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL
ALL_CEN =  wx.ALL|CEN
ALL_LEFT =  wx.ALL|LEFT
ALL_RIGHT =  wx.ALL|RIGHT

FONTSIZE = 11
if platform == 'linux':
    FONTSIZE = 10

</t>
<t tx="lkj.20190915160407.10">def onCreate(self, event=None):
    scut = self.make_Shortcut()
    script = "%s %s" % (scut.script, scut.args)

    make_shortcut(script.strip(),
                  name=scut.name,
                  description=scut.description,
                  folder=scut.folder,
                  icon=scut.icon,
                  terminal=self.opt_terminal.IsChecked())


</t>
<t tx="lkj.20190915160407.11">def onSavePy(self, event=None):
    scut = self.make_Shortcut()
    script = "%s %s" % (scut.script, scut.args)

    opts = dict(script=script.strip(),
                name=scut.name,
                desc=scut.description,
                folder=scut.folder,
                icon=scut.icon,
                terminal=repr(self.opt_terminal.IsChecked()))

    buff = ['#!/usr/bin/env python',
            'from pyshortcuts import make_shortcut',
            """make_shortcut('{script:s}',
    name='{name:s}',
    description='{desc:s}',
    folder='{folder:s}',
    icon='{icon:s}',
    terminal={terminal:s})""".format(**opts),
            '']

    wildcards = "%s|%s" % (PY_FILES, ALL_FILES)
    dlg = wx.FileDialog(self, message='Save Python script for creating shortcut',
                        defaultFile='make_shortcut.py',
                        wildcard=wildcards,
                        style=wx.FD_SAVE)

    if dlg.ShowModal() == wx.ID_OK:
        path = os.path.abspath(dlg.GetPath())
        with open(path, 'w') as fh:
            fh.write('\n'.join(buff))





</t>
<t tx="lkj.20190915160407.12">def onAbout(self, event):
    dlg = wx.MessageDialog(self, "pyshortcuts Graphical User Interface",
                           style=wx.OK|wx.ICON_INFORMATION)
    dlg.ShowModal()
    dlg.Destroy()

</t>
<t tx="lkj.20190915160407.13">def onExit(self, event):
    self.Destroy()

</t>
<t tx="lkj.20190915160407.2">class ShortcutFrame(wx.Frame):
    @others
if __name__ == '__main__':
    app = wx.App()
    ShortcutFrame().Show(True)
    app.MainLoop()
</t>
<t tx="lkj.20190915160407.3">def __init__(self):

    wx.Frame.__init__(self, None, -1, 'Pyshortcuts Creator',
                      style=wx.DEFAULT_FRAME_STYLE|wx.RESIZE_BORDER|wx.TAB_TRAVERSAL)
    self.SetTitle('Pyshortcuts Creator')

    self.SetFont(wx.Font(FONTSIZE, wx.SWISS, wx.NORMAL, wx.BOLD, False))
    menu = wx.Menu()
    menu_exit = menu.Append(-1, "Q&amp;uit", "Exit")

    menuBar = wx.MenuBar()
    menuBar.Append(menu, "&amp;File");
    self.SetMenuBar(menuBar)

    self.Bind(wx.EVT_MENU, self.onExit, menu_exit)
    self.Bind(wx.EVT_CLOSE, self.onExit)

    panel      = wx.Panel(self)

    opts = dict(size=(175, -1))
    lab_script = wx.StaticText(panel, label='  Python Script:', **opts)
    lab_args  = wx.StaticText(panel, label='  Command-line Arguments:', **opts)
    lab_name  = wx.StaticText(panel, label='  Shortcut Name:', **opts)
    lab_desc  = wx.StaticText(panel, label='  Description:', **opts)
    lab_icon  = wx.StaticText(panel, label='  Icon File:', **opts)
    lab_folder = wx.StaticText(panel, label='  Desktop SubFolder:', **opts)
    lab_opts  = wx.StaticText(panel, label='  Options:', **opts)

    opts['size'] = (400, -1)

    sopts = dict(size=(400, -1), style=wx.TE_PROCESS_ENTER)

    self.txt_script = wx.TextCtrl(panel, value='', **sopts)
    self.txt_args = wx.TextCtrl(panel, value='', **opts)
    self.txt_name = wx.TextCtrl(panel, value='', **sopts)
    self.txt_desc = wx.TextCtrl(panel, value='', **opts)
    self.txt_icon = wx.TextCtrl(panel, value='', **opts)
    self.txt_folder= wx.TextCtrl(panel, value='', **opts)

    self.txt_script.Bind(wx.EVT_TEXT_ENTER, self.onScriptEnter)
    self.txt_name.Bind(wx.EVT_TEXT_ENTER, self.onNameEnter)

    self.opt_terminal = wx.CheckBox(panel, label='Run in Terminal?',
                                    size=(200, -1))
    self.opt_terminal.SetValue(1)

    btn_script = wx.Button(panel, -1, label='Browse', size=(100, -1))
    btn_script.Bind(wx.EVT_BUTTON, self.onBrowseScript)

    btn_icon = wx.Button(panel, -1, label='Browse', size=(100, -1))
    btn_icon.Bind(wx.EVT_BUTTON, self.onBrowseIcon)

    btn_folder = wx.Button(panel, -1, label='Browse', size=(100, -1))
    btn_folder.Bind(wx.EVT_BUTTON, self.onBrowseFolder)

    sizer = wx.GridBagSizer(5, 5)

    irow = 0
    sizer.Add(wx.StaticLine(self, size=(650, 4)), (irow, 0), (1, 3), ALL_CEN)

    irow += 1
    sizer.Add(lab_script,      (irow, 0), (1, 1), ALL_LEFT)
    sizer.Add(self.txt_script, (irow, 1), (1, 1), ALL_LEFT)
    sizer.Add(btn_script,      (irow, 2), (1, 1), ALL_RIGHT)

    irow += 1
    sizer.Add(lab_args,       (irow, 0), (1, 1), ALL_LEFT)
    sizer.Add(self.txt_args,  (irow, 1), (1, 1), ALL_LEFT)

    irow += 1
    sizer.Add(lab_name,       (irow, 0), (1, 1), ALL_LEFT)
    sizer.Add(self.txt_name,  (irow, 1), (1, 1), ALL_LEFT)

    irow += 1
    sizer.Add(lab_desc,       (irow, 0), (1, 1), ALL_LEFT)
    sizer.Add(self.txt_desc,  (irow, 1), (1, 1), ALL_LEFT)

    irow += 1
    sizer.Add(lab_icon,       (irow, 0), (1, 1), ALL_LEFT)
    sizer.Add(self.txt_icon,  (irow, 1), (1, 1), ALL_LEFT)
    sizer.Add(btn_icon,       (irow, 2), (1, 1), ALL_RIGHT)

    irow += 1
    sizer.Add(lab_folder,      (irow, 0), (1, 1), ALL_LEFT)
    sizer.Add(self.txt_folder, (irow, 1), (1, 1), ALL_LEFT)
    sizer.Add(btn_folder,      (irow, 2), (1, 1), ALL_RIGHT)

    irow += 1
    sizer.Add(lab_opts,         (irow, 0), (1, 1), ALL_LEFT)
    sizer.Add(self.opt_terminal, (irow, 1), (1, 1), ALL_LEFT)

    irow += 1
    sizer.Add(wx.StaticLine(self, size=(650, 4)), (irow, 0), (1, 3), ALL_CEN)

    btn_create = wx.Button(panel, label='Create Shortcut',  size=(175, -1))
    btn_create.Bind(wx.EVT_BUTTON, self.onCreate)

    btn_savepy = wx.Button(panel, label='Save Python Code', size=(175, -1))
    btn_savepy.Bind(wx.EVT_BUTTON, self.onSavePy)


    bsizer = wx.BoxSizer(wx.HORIZONTAL)
    bsizer.Add(btn_create, 1,  ALL_LEFT, 3)
    bsizer.Add(btn_savepy, 1,  ALL_LEFT, 3)

    irow += 1
    sizer.Add(bsizer, (irow, 0), (1, 3), ALL_LEFT)

    panel.SetSizer(sizer)
    sizer.Fit(panel)

    fsizer = wx.BoxSizer(wx.VERTICAL)
    fsizer.Add(panel, 0, wx.ALIGN_LEFT|wx.ALIGN_CENTER|wx.EXPAND)
    fsizer.Fit(self)
    self.Refresh()

</t>
<t tx="lkj.20190915160407.4">def onBrowseScript(self, event=None):
    wildcards = "%s|%s" % (PY_FILES, ALL_FILES)

    dlg = wx.FileDialog(self, message='Select Python Script file',
                        wildcard=wildcards,
                        style=wx.FD_OPEN)

    if dlg.ShowModal() == wx.ID_OK:
        path = os.path.abspath(dlg.GetPath())
        self.txt_script.SetValue(path)

        _, name = os.path.split(path)
        name = fix_filename(name)
        if name.endswith('.py'):
            name = name[:-3]

        txt_name = self.txt_name.GetValue().strip()
        if len(txt_name) &lt; 1:
            self.txt_name.SetValue(name)

        txt_desc = self.txt_desc.GetValue().strip()
        if len(txt_desc) &lt; 1:
            self.txt_desc.SetValue(name)
    dlg.Destroy()


</t>
<t tx="lkj.20190915160407.5">def onBrowseIcon(self, event=None):

    wildcards = "%s|%s" % (ICO_FILES, ALL_FILES)
    if platform.startswith('darwin'):
        wildcards = "%s|%s" % (ICNS_FILES, ALL_FILES)

    dlg = wx.FileDialog(self, message='Select Icon file',
                        wildcard=wildcards,
                        style=wx.FD_OPEN)

    if dlg.ShowModal() == wx.ID_OK:
        path = os.path.abspath(dlg.GetPath())
        self.txt_icon.SetValue(path)
    dlg.Destroy()


</t>
<t tx="lkj.20190915160407.6">def onBrowseFolder(self, event=None):
    defdir = self.txt_folder.GetValue()
    if defdir in ('', 'Desktop'):
        defdir = os.path.join(get_homedir(), 'Desktop')
    dlg = wx.DirDialog(self,
                       message='Select Folder for Shortcut',
                       defaultPath=defdir,
                       style = wx.DD_DEFAULT_STYLE)

    if dlg.ShowModal() == wx.ID_OK:
        folder = os.path.abspath(dlg.GetPath())
        desktop = os.path.join(get_homedir(), 'Desktop')
        if folder.startswith(desktop):
            folder.replace(desktop, '')
            if folder.startswith('/'):
                folder = folder[1:]
        self.txt_folder.SetValue(folder)
    dlg.Destroy()


</t>
<t tx="lkj.20190915160407.7">def onScriptEnter(self, event=None):
    path = self.txt_script.GetValue()

    _, name = os.path.split(path)
    name = fix_filename(name)
    if name.endswith('.py'):
        name = name[:-3]

    txt_name = self.txt_name.GetValue().strip()
    if len(txt_name) &lt; 1:
        self.txt_name.SetValue(name)

    txt_desc = self.txt_desc.GetValue().strip()
    if len(txt_desc) &lt; 1:
        self.txt_desc.SetValue(name)


</t>
<t tx="lkj.20190915160407.8">def onNameEnter(self, event=None):
    name = self.txt_name.GetValue()
    txt_desc = self.txt_desc.GetValue().strip()
    if len(txt_desc) &lt; 1:
        self.txt_desc.SetValue(name)

</t>
<t tx="lkj.20190915160407.9">def make_Shortcut(self):
    script = self.txt_script.GetValue() or None
    args = self.txt_args.GetValue() or None
    name = self.txt_name.GetValue() or None
    desc = self.txt_desc.GetValue() or None
    icon = self.txt_icon.GetValue() or None
    folder = self.txt_folder.GetValue() or None

    if script is None:
        dlg = wx.MessageDialog(self, "script required",
                               style=wx.OK|wx.ICON_INFORMATION)
        dlg.ShowModal()
        dlg.Destroy()
        return

    if folder is not None:
        desktop = os.path.join(get_homedir(), 'Desktop')
        if folder.startswith(desktop):
            folder.replace(desktop, '')
            if folder.startswith('/'):
                folder = folder[1:]

    if args is not None:
        script = "%s %s" % (script, args)

    return Shortcut(script, name=name, description=desc,
                    folder=folder, icon=icon)

</t>
<t tx="lkj.20190915160754.1"></t>
<t tx="lkj.20190919213126.1">@nosearch
@language python

# flattened, ignore-case, head, body

# found 9 nodes</t>
<t tx="lkj.20190919213421.1">@nosearch
@language python
# flattened, ignore-case, head, body

# found 13 nodes</t>
<t tx="lkj.20190919214201.1">def get_folders():
    """Return named tuple of Home, Desktop and Startmenu paths.

        folders = get_win_folders()
        print("Home, Desktop, StartMenu ",
            folders.home, folders.desktop, folders.startmenu)
    """
    import win32com.client
    from collections import namedtuple

    shellapp = win32com.client.Dispatch("Shell.Application")

    nt = namedtuple("folders", "home desktop startmenu")
    folders = nt(
        shellapp.namespace(40).self.path,
        shellapp.namespace(0).self.path,
        shellapp.namespace(11).self.path,
    )
    return folders
    # Windows Special Folders
    # ID numbers from https://gist.github.com/maphew/47e67b6a99e240f01aced8b6b5678eeb
    # https://docs.microsoft.com/en-gb/windows/win32/api/shldisp/ne-shldisp-shellspecialfolderconstants#constants
    #
    # Start menu: user = 11, all users = 22
    # Desktop   : user =  0, all users = 25
    # Profile   : = 40, same as %USERPROFILE%
</t>
<t tx="lkj.20190919235058.1">@nosearch

# flattened, ignore-case, head, body

# found 3 nodes</t>
</tnodes>
</leo_file>
