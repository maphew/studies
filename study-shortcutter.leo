<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="mhw.20190808084549.2"><vh>Shortcutter</vh>
<v t="mhw.20190808085013.1"><vh>@path ../shortcutter</vh>
<v t="mhw.20190808092452.15"><vh>/conda-forge/</vh></v>
<v t="mhw.20190808092452.14"><vh>/docs/</vh></v>
<v t="mhw.20190808092452.13"><vh>/shortcutter.egg-info/</vh></v>
<v t="mhw.20190808092452.12"><vh>/shortcutter/</vh>
<v t="mhw.20190808085024.7"><vh>@auto __init__.py</vh></v>
<v t="mhw.20190808085024.6"><vh>@auto _version.py</vh></v>
<v t="mhw.20190808085024.5"><vh>@auto base.py</vh></v>
<v t="mhw.20190808085024.4"><vh>@auto exception.py</vh></v>
<v t="mhw.20190808085024.3"><vh>@auto linux.py</vh></v>
<v t="mhw.20190808085024.2"><vh>@auto macos.py</vh></v>
<v t="mhw.20190808085024.1"><vh>@auto windows.py</vh></v>
</v>
<v t="mhw.20190808092452.11"><vh>CHANGE_LOG.md</vh></v>
<v t="mhw.20190808092452.10"><vh>LICENSE</vh></v>
<v t="mhw.20190808092452.9"><vh>MANIFEST.in</vh></v>
<v t="mhw.20190808092452.8"><vh>README.md</vh></v>
<v t="mhw.20190808092452.7"><vh>api.rst</vh></v>
<v t="mhw.20190808092452.6"><vh>setup.cfg</vh></v>
<v t="mhw.20190808092452.5"><vh>setup.py</vh></v>
<v t="mhw.20190808092452.4"><vh>update_and_upload.txt</vh></v>
<v t="mhw.20190808092452.3"><vh>update_rst</vh></v>
<v t="mhw.20190808092452.2"><vh>upload</vh></v>
<v t="mhw.20190808092452.1"><vh>versioneer.py</vh></v>
</v>
</v>
<v t="mhw.20190808090216.1"><vh>modified</vh>
<v t="mhw.20190808092640.11"><vh>ShortCutterWindows(ShortCutter)._create_shortcut_win</vh></v>
<v t="mhw.20190808121627.15"><vh>ShortCutter(object).create_desktop_shortcut</vh></v>
<v t="mhw.20190808121627.16"><vh>ShortCutter(object).create_menu_shortcut</vh></v>
<v t="mhw.20190808122913.15"><vh>ShortCutter(object).create_menu_shortcut</vh></v>
</v>
<v t="mhw.20190808121955.1"><vh>Found:create_desktop_shortcut</vh>
<v t="mhw.20190808121627.3"><vh>class ShortCutter(object)</vh>
<v t="mhw.20190808121627.4"><vh>ShortCutter(object).__init__</vh></v>
<v t="mhw.20190808121627.5"><vh>ShortCutter(object)._set_win_vars</vh></v>
<v t="mhw.20190808121627.6"><vh>ShortCutter(object)._get_desktop_folder</vh></v>
<v t="mhw.20190808121627.7"><vh>ShortCutter(object)._get_menu_folder</vh></v>
<v t="mhw.20190808121627.8"><vh>ShortCutter(object)._get_bin_folder_pyexe</vh></v>
<v t="mhw.20190808121627.9"><vh>ShortCutter(object)._get_activate_wrapper_templates</vh></v>
<v t="mhw.20190808121627.10"><vh>ShortCutter(object)._make_executable</vh></v>
<v t="mhw.20190808121627.11"><vh>ShortCutter(object).exe</vh></v>
<v t="mhw.20190808121627.12"><vh>ShortCutter(object).ba</vh></v>
<v t="mhw.20190808121627.13"><vh>ShortCutter(object)._get_activate_args</vh></v>
<v t="mhw.20190808121627.14"><vh>ShortCutter(object)._check_if_conda_root</vh></v>
<v t="mhw.20190808121627.15"></v>
<v t="mhw.20190808121627.16"></v>
<v t="mhw.20190808121627.17"><vh>ShortCutter(object)._path_to_name</vh></v>
<v t="mhw.20190808121627.18"><vh>ShortCutter(object)._ascii_name</vh></v>
<v t="mhw.20190808121627.19"><vh>ShortCutter(object)._create_wrapped_shortcut</vh></v>
<v t="mhw.20190808121627.20"><vh>ShortCutter(object).create_shortcut</vh></v>
<v t="mhw.20190808121627.21"><vh>ShortCutter(object)._safe_create</vh></v>
<v t="mhw.20190808121627.22"><vh>ShortCutter(object).create_shortcut_to_env_terminal</vh></v>
<v t="mhw.20190808121627.23"><vh>ShortCutter(object)._create_shortcut_to_dir</vh></v>
<v t="mhw.20190808121627.24"><vh>ShortCutter(object)._create_shortcut_file</vh></v>
<v t="mhw.20190808121627.25"><vh>ShortCutter(object).makedirs</vh></v>
<v t="mhw.20190808121627.26"><vh>ShortCutter(object).find_target</vh></v>
<v t="mhw.20190808121627.27"><vh>ShortCutter(object).search_for_target</vh></v>
<v t="mhw.20190808121627.28"><vh>ShortCutter(object)._is_file_the_target</vh></v>
<v t="mhw.20190808121627.29"><vh>ShortCutter(object)._get_paths</vh></v>
</v>
<v t="mhw.20190808121626.4"><vh>main (__init__.py)</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="mhw.20190808084549.2">Easy cross-platform creation of shortcuts supporting virtual and Anaconda environments

Upstream: https://github.com/kiwi0fruit/shortcutter
My fork: https://github.com/maphew/shortcutter.git


@path ../shortcutter
</t>
<t tx="mhw.20190808085013.1"></t>
<t tx="mhw.20190808090216.1">@language python
@tabwidth -4
</t>
<t tx="mhw.20190808092452.1"></t>
<t tx="mhw.20190808092452.10"></t>
<t tx="mhw.20190808092452.11"></t>
<t tx="mhw.20190808092452.12">@path shortcutter</t>
<t tx="mhw.20190808092452.13">@path shortcutter.egg-info</t>
<t tx="mhw.20190808092452.14">@path docs</t>
<t tx="mhw.20190808092452.15">@path conda-forge</t>
<t tx="mhw.20190808092452.2"></t>
<t tx="mhw.20190808092452.3"></t>
<t tx="mhw.20190808092452.4"></t>
<t tx="mhw.20190808092452.5"></t>
<t tx="mhw.20190808092452.6"></t>
<t tx="mhw.20190808092452.7"></t>
<t tx="mhw.20190808092452.8"></t>
<t tx="mhw.20190808092452.9"></t>
<t tx="mhw.20190808092640.11">def _create_shortcut_win(self, shortcut_name, target_path, shortcut_directory, folder=False, icon=None):
    """
    Creates a Windows shortcut file.

    Returns tuple (shortcut_name, target_path, shortcut_file_path)
    """
    #icon = r"D:\code-maphew\leo-editor\leo\Icons\LeoApp.ico"
    if not folder:
        shortcut_target_path = target_path
        working_directory = p.dirname(target_path)
        ext = p.splitext(target_path)[1].upper()
        if not icon:
            if ext in self._executable_file_extensions:
                icon = r'%SystemRoot%\System32\imageres.dll,11'
    
    elif not p.isdir(target_path):
        # create a bat script that opens the folder:
        
        wrapper_path = p.join(self.bin_folder_shcut, self.ba('shortcutter__dir__' + self._path_to_name(target_path)))
        with open(wrapper_path, 'w') as f:
            f.write(FOLDER_SHORTCUT.format(path=target_path))
        shortcut_target_path = wrapper_path
        working_directory = self.bin_folder_shcut
        icon = r'%SystemRoot%\explorer.exe,0'

    else:
        shortcut_target_path = target_path
        working_directory = target_path

    shortcut_file_path = p.join(shortcut_directory, shortcut_name + ".lnk")
    shortcut = shell.CreateShortCut(shortcut_file_path)
    shortcut.Targetpath = shortcut_target_path
    shortcut.WorkingDirectory = working_directory
    shortcut.Description = "Shortcut to" + p.basename(target_path)
    if icon:
        shortcut.IconLocation = icon
    shortcut.save()

    return shortcut_name, target_path, shortcut_file_path

</t>
<t tx="mhw.20190808121626.4">def main():
    from argparse import ArgumentParser

    parser = ArgumentParser(description="Automatic shortcut creator." +
                                        " Shortcuts auto-activate their environments by default.")
    parser.add_argument("target", nargs='?', default=None,
                        help="The target executable to create Desktop and Menu shortcuts.")
    parser.add_argument("-d", "--desktop", action="store_true", help="Only create a desktop shortcut.")
    parser.add_argument("-m", "--menu", action="store_true", help="Only create a menu shortcut.")
    parser.add_argument("-n", "--name", nargs='?', default=None, help="Name of the shortcut without extension (autoname otherwise).")
    parser.add_argument("-s", "--simple", action="store_true", help="Create simple shortcut without activate wrapper.")
    parser.add_argument("-t", "--terminal", action="store_true",
                        help="Create shortcut to environment with shortcutter " +
                             "(plus shortcut to root environment in case of conda).")
    args = parser.parse_args()

    create_desktop = args.desktop
    create_menu = args.menu
    activate = not args.simple
    name = args.name if args.name else None

    if not args.target and not args.terminal:
        print('Shortcutter needs target or --terminal arguments to work.')
        return

    # if desktop or menu hasnt been specified create both (i.e. the default)
    if not create_desktop and not create_menu:
        create_desktop = True
        create_menu = True

    sc = ShortCutter(activate=activate, error_log=sys.stdout)

    target_path = sc.find_target(args.target)
    if target_path or args.terminal:

        desktop_created = False
        if create_desktop:
            if args.terminal:
                desktop_created = sc.create_shortcut_to_env_terminal(name, menu=False)
            else:
                ret = sc.create_desktop_shortcut(target_path, name)
                desktop_created = bool(ret[2])  # shortcut_path = ret[2]
            if not desktop_created:
                print("Failed to create desktop shortcut.")

        menu_created = False
        if create_menu:
            if args.terminal:
                menu_created = sc.create_shortcut_to_env_terminal(name, desktop=False)
            else:
                ret = sc.create_menu_shortcut(target_path, name)
                menu_created = bool(ret[2])  # shortcut_path = ret[2]
            if not menu_created:
                print("Failed to create menu shortcut.")

        msg = "created for '{}'.".format(args.target if not args.terminal else 'terminal at environment')
        if desktop_created and menu_created:
            print('Desktop and menu shortcuts were ' + msg)
        elif desktop_created and not menu_created:
            print('Desktop shortcut was ' + msg)
        elif not desktop_created and menu_created:
            print('Menu shortcut was ' + msg)
    else:
        print("Shortcut creation failed: unable to find '{}'.".format(args.target))
</t>
<t tx="mhw.20190808121627.10">@staticmethod
def _make_executable(file_path):
    raise ShortcutError("_make_executable needs overriding")

</t>
<t tx="mhw.20190808121627.11">def exe(self, app_name):
    """
    Returns platform independent executable name:

    * app &gt; app (on Unix)
    * app &gt; app.exe (on Windows)
    """
    if os.name == 'nt':
        return app_name + '.exe'
    else:
        return app_name

</t>
<t tx="mhw.20190808121627.12">def ba(self, script_name):
    """
    Returns platform independent shell script (bash/batch) name:

    * run &gt; run (on Unix)
    * run &gt; run.bat (on Windows)
    """
    if os.name == 'nt':
        return script_name + '.bat'
    else:
        return script_name

</t>
<t tx="mhw.20190808121627.13">def _get_activate_args(self):
    """
    Returns tuple: (str or None, str or None).

    First is the activate script full path (or None if it's wasn't found) - conda's or venv's.

    Second is the env argument of the activate script (or None if not needed).
    """
    if p.isdir(p.join(self.local_root, 'conda-meta')):
        # check if we are installing to conda root:
        activate = self._check_if_conda_root(self.local_root)
        if activate:
            return activate, None

        # check if we are installing to default conda env location:
        #   `&lt;conda_root&gt;/envs/&lt;local_root_basename&gt;`
        ddot = p.dirname(self.local_root)
        activate = self._check_if_conda_root(p.dirname(ddot))
        if (p.basename(ddot) == 'envs') and activate: 
            return activate, p.basename(self.local_root)

        # check if we are running pip via `conda env create -f env.yaml`
        #   or user specified `CONDA_ROOT` env var himself:
        conda_root = os.environ.get('CONDA_ROOT')
        activate = self._check_if_conda_root(conda_root)
        if activate:
            if p.isabs(conda_root):
                return activate, self.local_root

        # check if there is conda in the PATH:
        conda = self.find_target('conda')
        if conda is not None:
            conda_root = p.dirname(p.dirname(conda))
            activate = self._check_if_conda_root(conda_root)
            if activate:
                return activate, self.local_root

        return None, self.local_root
    else:
        # check if we are installing to venv:
        activate = p.join(self.bin_folder_pyexe, self.ba('activate'))
        if p.isfile(activate):
            return activate, None

    return None, None
 
</t>
<t tx="mhw.20190808121627.14">def _check_if_conda_root(self, path):
    """
    Checks if provided path is conda root. It should have
    conda-meta folder, conda executable, activate shell script.

    Returns path to conda activate script or None.
    """
    if path is not None:
        if p.isdir(p.join(path, 'conda-meta')):
            conda = p.join(path,
                           p.basename(self.bin_folder_pyexe),
                           self.exe('conda'))
            # check if the file executable:
            if p.isfile(conda) and os.access(conda, os.X_OK):
                activate = p.join(p.dirname(conda), self.ba('activate'))
                if p.isfile(activate):
                    return p.abspath(activate)
    return None

</t>
<t tx="mhw.20190808121627.15">def create_desktop_shortcut(self, target, shortcut_name=None, icon=None):
    """
    Creates a desktop shortcut to a target.

    Parameters
    ----------
    target : str
        The target to create a shortcut for, it can be a fully qualified
        file path ``/path/to/my_program`` or a simple application name 
        ``my_program``.
    shortcut_name : str=None
        Name of the shortcut without extension (``.lnk`` would be appended if needed).
        If None uses the target filename.
    icon : str=None
        Path to icon file

    Returns
    -------
    tuple (str or None, str or None, str or None)
        (shortcut_name, target_path, shortcut_file_path)
    """
    if not p.isdir(self.desktop_folder):
        msg = "Desktop folder '{}' not found.".format(self.desktop_folder)
        if self.raise_errors:
            raise ShortcutNoDesktopError(msg)
        elif self.error_log is not None:
            self.error_log.write(msg + '\n')
            return None, None, None
    else:
        return self.create_shortcut(target, self.desktop_folder, shortcut_name)

</t>
<t tx="mhw.20190808121627.16">def create_menu_shortcut(self, target, shortcut_name=None, icon=None):
    """
    Creates a menu shortcut to a target.

    Parameters
    ----------
    target : str
        The target to create a shortcut for, it can be a fully qualified
        file path ``/path/to/my_program`` or a simple application name 
        ``my_program``.
    shortcut_name : str=None
        Name of the shortcut without extension (``.lnk`` would be appended if needed).
        If None uses the target filename.
    icon : str=None
        Path to icon file

    Returns
    -------
    tuple (str or None, str or None, str or None)
        (shortcut_name, target_path, shortcut_file_path)
    """
    if not p.isdir(self.menu_folder):
        msg = "Menu folder '{}' not found.".format(self.menu_folder)
        if self.raise_errors:
            raise ShortcutNoMenuError(msg)
        elif self.error_log is not None:
            self.error_log.write(msg + '\n')
            return None, None, None
    else:
        return self.create_shortcut(target, self.menu_folder, shortcut_name)

</t>
<t tx="mhw.20190808121627.17">@classmethod
def _path_to_name(cls, path):
    """
    Takes three last items from the absolutized path and converts to
    name by replacing everything except `A-Za-z0-9` to `_`
    """
    dirs = '_'.join(p.abspath(path).split(os.sep)[-3:-1])
    return cls._ascii_name('{}__at__{}'.format(p.basename(path), dirs))

</t>
<t tx="mhw.20190808121627.18">@staticmethod
def _ascii_name(name):
    w_unicode_name = re.sub(r'\W', '_', name)
    w_ascii_name = str(w_unicode_name.encode('utf-8'))[1:].strip('"').strip("'").replace('\\', '_')
    return w_ascii_name

</t>
<t tx="mhw.20190808121627.19">def _create_wrapped_shortcut(self, shortcut_name, target_path, shortcut_directory, activate_args=None):
    """
    Creates shell script wrapper for shortcut with activation.
    
    Providing activate_args optional argument switches to creation
    of shortcut to terminal with activated environment.
    
    Returns a tuple of (shortcut_name, target_path, shortcut_file_path)
    """
    if activate_args is None:
        activate, env = self.activate_args
        terminals = False
        name = self._path_to_name(target_path)
    else:
        activate, env = activate_args
        terminals = True
        target_path = None
        name = self._ascii_name(shortcut_name)

    wrapper_path = p.join(self.bin_folder_shcut, self.ba('shortcutter__' + name))
    if target_path or terminals:
        def r(path):
            if path is None:
                return ''
            else:
                return path.replace('"', r'\"').replace("'", r"\'")

        def call_batch(path):
            if path is None:
                return ''
            elif os.name == 'nt' and (path.endswith('.bat') or path.endswith('.cmd')):
                return 'call '
            else:
                return ''

        script = (self._ACTIVATE_PROMPT if terminals else self._ACTIVATE).format(
            activate=r(activate) + ('" "' + r(env) if env else ''),
            executable=r(target_path),
            bin=r(p.dirname(activate)),
            call=call_batch(target_path)
        )
        with open(wrapper_path, 'w') as f:
            f.write(script)
            self._make_executable(wrapper_path)
    return self._create_shortcut_file(shortcut_name, wrapper_path, shortcut_directory)

</t>
<t tx="mhw.20190808121627.20">def create_shortcut(self, target, shortcut_directory, shortcut_name=None):
    """
    Creates a shortcut to a target.

    Parameters
    ----------
    target : str
        The target to create a shortcut for, it can be a fully qualified
        file path ``/path/to/my_program`` or a simple application name 
        ``my_program``.
    shortcut_directory : str
        The directory path where the shortcut should be created.
    shortcut_name : str=None
        Name of the shortcut without extension (``.lnk`` would be appended if needed).
        If None uses the target filename.

    Returns
    -------
    tuple (str, str, str or None)
        (shortcut_name, target_path, shortcut_file_path)
    """
    # Set the target path:
    target_path = self.find_target(target)

    # Check if target is dir or file:
    isdir = False
    if target_path:
        if p.isdir(target_path):
            isdir = True

    if not target_path and not self.exists:
        if target.endswith(os.sep):
            isdir = True
        target_path = p.abspath(target)

    # Set shortcut name:
    if shortcut_name is None:
        if isdir:
            shortcut_name = p.basename(target)
        else:
            # getting the file name and removing the extension:
            shortcut_name = p.splitext(p.basename(target))[0]

    # Create shortcut function:
    def create():
        if not target_path:
            raise ShortcutError(
                "Target '{}' wasn't found or invalid target/exists ('{}') options combination.".format(target,
                                                                                                       self.exists))

        if isdir:
            return self._create_shortcut_to_dir(shortcut_name, target_path, shortcut_directory)

        elif self.activate:
            activate, env = self.activate_args
            if activate:
                return self._create_wrapped_shortcut(shortcut_name, target_path, shortcut_directory)

            elif (not activate) and env:
                raise ShortcutError('Shortcutter failed to find conda root (or activate script there). ' +
                                    'It searched in `../../` assuming default env location ' +
                                    '(`../` should have `envs` basename). ' +
                                    'Checked `CONDA_ROOT` environment variable. ' +
                                    'Searched `conda` executable in the PATH.')
        # Use simple shortcuts if self.activate=False or we are installing to common python installation:
        return self._create_shortcut_file(shortcut_name, target_path, shortcut_directory)

    ret = self._safe_create(create)
    return ret if (ret != 'error') else (shortcut_name, target_path, None)

</t>
<t tx="mhw.20190808121627.21">def _safe_create(self, create):
    """
    Switches shortcuts creation function error modes.

    :param create:
        function to call (without arguments)
    """
    if self.raise_errors:
        ret = create()
    else:
        try:
            ret = create()
        except Exception:
            ret = 'error'
            if self.error_log is not None:
                self.error_log.write(''.join(traceback.format_exc()))
    return ret

</t>
<t tx="mhw.20190808121627.22">def create_shortcut_to_env_terminal(self, shortcut_name=None, shortcut_directory=None, desktop=True, menu=True):
    """
    Creates shortcuts for console (terminal) that
    has already activated the environment we are installing to
    (plus shortcut to root environment in case of conda).

    Parameters
    ----------
    shortcut_name : str=None
        Name of the shortcut without extension (``.lnk`` would be appended if needed).
        If None uses the target filename.
    shortcut_directory : str=None
        The directory path where the shortcuts should be created.
    desktop : bool=True
        Whether to create shortcuts on the desktop.
    menu : bool=True
        Whether to create shortcuts in the menu.

    Returns
    -------
    bool
        True if all operations were successful, False otherwise.
    """
    activate, env = self.activate_args
    if not activate:
        return
    if not shortcut_name:
        shortcut_name = 'Terminal at '

    ret = []
    for check, path, pref in [(desktop, self.desktop_folder, 'Desktop folder'),
                              (menu, self.menu_folder, 'Menu folder'),
                              (shortcut_directory is not None, shortcut_directory, 'Directory')]:
        if check:
            if not p.isdir(path):
                msg = "{} '{}' not found.".format(pref, path)
                if self.raise_errors:
                    raise ShortcutNoDesktopError(msg)
                elif self.error_log is not None:
                    self.error_log.write(msg + '\n')
                    ret.append('error')
            else:
                name = shortcut_name + p.basename(p.dirname(p.dirname(activate)))
                ret.append(self._safe_create(
                    lambda: self._create_wrapped_shortcut(name, None, path, (activate, None))
                ))
                if env:
                    name = shortcut_name + p.basename(env)
                    ret.append(self._safe_create(
                        lambda: self._create_wrapped_shortcut(name, None, path, (activate, env))
                    ))
    return False if ('error' in ret) else True

# should be overridden
</t>
<t tx="mhw.20190808121627.23">def _create_shortcut_to_dir(self, shortcut_name, target_path, shortcut_directory):
    raise ShortcutError("_create_shortcut_to_dir needs overriding")

# should be overridden
</t>
<t tx="mhw.20190808121627.24">def _create_shortcut_file(self, shortcut_name, target_path, shortcut_directory):
    raise ShortcutError("_create_shortcut_file needs overriding")

</t>
<t tx="mhw.20190808121627.25">def makedirs(self, *args):
    """
    Recursively creates dirs if they don't exist.
    Utilizes ``self.raise_errors`` and ``self.error_log``.
    
    Parameters
    ----------
    \*args : str
        Multiple paths (str) for folders to create.

    Returns
    -------
    bool
        True on success False of failure.
    """
    ret = []
    for path in args:
        if not p.isdir(path):
            ret.append(self._safe_create(lambda: os.makedirs(path)))

    return False if ('error' in ret) else True

</t>
<t tx="mhw.20190808121627.26">def find_target(self, target):
    """
    Finds a file path for a target application.
    Single-worded targets like ``'app'`` are always searched in the PATH.
    You should prepend ``./app`` to tell that the file is in the CWD.

    Parameters
    ----------
    target : str
        The target to find, it can be a fully qualified
        file path ``/path/to/my_program`` or a simple application name 
        ``my_program``.

    Returns
    -------
    str or None
        Returns a single target file path or ``None`` if a path can't be found.
    """
    if target:
        if p.basename(target) == target:
            targets = self.search_for_target(target)
            if len(targets) &gt; 0:
                return p.abspath(targets[0])
            else:
                return None
        elif p.isfile(target) or p.isdir(target):
            return p.abspath(target)
    return None

</t>
<t tx="mhw.20190808121627.27">def search_for_target(self, target):
    """
    Searches for a target application.

    Parameters
    ----------
    target : str
        The target to find.

    Returns
    -------
    list(str)
        Returns a list of potential target file paths, it no paths are found an empty list is returned.
    """
    # potential list of app paths
    target_paths = []

    # create list of potential directories
    paths = self._get_paths()

    # loop through each folder
    for path in paths:
        if p.exists(path):
            if p.isdir(path):
                # get files in directory
                for file_name in os.listdir(path):
                    file_path = p.join(path, file_name)
                    if p.isfile(file_path):
                        if self._is_file_the_target(target, file_name, file_path):
                            target_paths.append(file_path)
            else:
                # its not a directory, is it the app we are looking for?
                pass

    return target_paths

# needs overriding
</t>
<t tx="mhw.20190808121627.28">def _is_file_the_target(self, target, file_name, file_path):
    raise ShortcutError("_is_file_the_target needs overriding")

# needs overriding
</t>
<t tx="mhw.20190808121627.29">@staticmethod
def _get_paths():
    raise ShortcutError("_get_paths needs overriding")
</t>
<t tx="mhw.20190808121627.3">class ShortCutter(object):
    """
    Creates applicaton shortcuts for Windows, MacOS and Linux operating systems.

    To create desktop and menu shortcuts to ``python``::

        from shortcutter import ShortCutter
        s = ShortCutter()
        s.create_desktop_shortcut("python")
        s.create_menu_shortcut("python")

    Attributes:
    -----------
    raise_errors : bool=False
        Whether to raise exceptions or skip errors and continue.
    error_log : object=None
        File object where to write errors when ``raise_errors=False``.
        Default is None - do not write errors.
        Can also be ``sys.stderr`` or ``io.StringIO()``.
    desktop_folder : str
        Directory used when creating desktop shortcuts.
    menu_folder : str
        Directory used when creating menu shortcuts.
    bin_folder_pyexe : str
        ``Scripts`` or ``bin`` dir path. Simply closest to python executable path.
    bin_folder_shcut : str or None
        ``Scripts`` or ``bin`` dir path where shortcutter executable was installed.
    local_root : str
        Root directory path of the current python environment / installation.
        Derived from python executable path.
    activate : bool=True
        Whether to create shortcuts that automatically activate
        conda environment / virtual environment.
    exists : bool=True
        Whether the target should exist or not.
        If not then add ``/`` (``\\`` on Windows) at the end of the path to get dir shortcut.
    activate_args : tuple (str or None, str or None)
        First is the activate script full path (or None if it's wasn't found) - conda's or venv's.
        Second is the env argument of the activate script (or None if not needed).
    """

    @others
</t>
<t tx="mhw.20190808121627.4">def __init__(self, raise_errors=False, error_log=None, activate=True, exists=True):
    """
    Creates ShortCutter.

    Parameters
    ----------
    raise_errors : bool=False
        Whether to raise exceptions or skip errors and continue.
    error_log : object=None
        File object where to write errors when ``raise_errors=False``.
        Default is None - do not write errors.
        Can also be ``sys.stderr`` or ``io.StringIO()``.
    activate : bool=True
        Whether to create shortcuts that automatically activate
        conda environment / virtual environment.
    exists : bool=True
        Whether the target should exist or not.
        If not then add ``/`` (``\\`` on Windows) at the end of the path to get dir shortcut.
    """
    self._set_win_vars()  # important on Windows

    self.raise_errors = raise_errors
    self.error_log = error_log
    self.activate = activate
    self.exists = exists
    self.desktop_folder = self._get_desktop_folder()
    self.menu_folder = self._get_menu_folder()
    self.bin_folder_pyexe = self._get_bin_folder_pyexe()
    shortcutter = self.find_target('shortcutter')
    self.bin_folder_shcut = p.dirname(shortcutter) if shortcutter else self.bin_folder_pyexe
    self.local_root = sys.prefix
    self._ACTIVATE, self._ACTIVATE_PROMPT = self._get_activate_wrapper_templates()

    self.activate_args = self._get_activate_args()  # should be run the last

# might be overridden if needed
</t>
<t tx="mhw.20190808121627.5">def _set_win_vars(self):
    pass

# should be overridden
</t>
<t tx="mhw.20190808121627.6">@staticmethod
def _get_desktop_folder():
    raise ShortcutError("_get_desktop_folder needs overriding")

# should be overridden
</t>
<t tx="mhw.20190808121627.7">@staticmethod
def _get_menu_folder():
    raise ShortcutError("_get_menu_folder needs overriding")

# should be overridden
</t>
<t tx="mhw.20190808121627.8">@staticmethod
def _get_bin_folder_pyexe():
    raise ShortcutError("_get_bin_folder_pyexe needs overriding")

# should be overridden
</t>
<t tx="mhw.20190808121627.9">@staticmethod
def _get_activate_wrapper_templates():
    raise ShortcutError("_get_activate_wrapper_templates needs overriding")

# should be overridden
</t>
<t tx="mhw.20190808121955.1">@nosearch
@language python
# flattened, ignore-case, head, body

# found 3 nodes</t>
<t tx="mhw.20190808122913.15">def create_menu_shortcut(self, target, shortcut_name=None, icon=None):
    """
    Creates a menu shortcut to a target.

    Parameters
    ----------
    target : str
        The target to create a shortcut for, it can be a fully qualified
        file path ``/path/to/my_program`` or a simple application name 
        ``my_program``.
    shortcut_name : str=None
        Name of the shortcut without extension (``.lnk`` would be appended if needed).
        If None uses the target filename.
    icon : str=None
        Path to icon file

    Returns
    -------
    tuple (str or None, str or None, str or None)
        (shortcut_name, target_path, shortcut_file_path)
    """
    if not p.isdir(self.menu_folder):
        msg = "Menu folder '{}' not found.".format(self.menu_folder)
        if self.raise_errors:
            raise ShortcutNoMenuError(msg)
        elif self.error_log is not None:
            self.error_log.write(msg + '\n')
            return None, None, None
    else:
        return self.create_shortcut(target, self.menu_folder, shortcut_name)

</t>
</tnodes>
</leo_file>
