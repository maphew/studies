<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="mhw.20190808084549.2"><vh>Shortcutter</vh>
<v t="mhw.20190808085013.1"><vh>@path ../shortcutter</vh>
<v t="mhw.20190808092452.15"><vh>/conda-forge/</vh></v>
<v t="mhw.20190808092452.14"><vh>/docs/</vh></v>
<v t="mhw.20190808092452.12"><vh>/shortcutter/</vh>
<v t="mhw.20190808085024.7"><vh>@clean __init__.py</vh>
<v t="lkj.20190808195546.1"><vh>Declarations (__init__.py)</vh></v>
<v t="lkj.20190808195546.2"><vh>main (__init__.py)</vh></v>
</v>
<v t="mhw.20190808085024.6"><vh>@clean _version.py</vh>
<v t="lkj.20190808195546.3"><vh>Declarations (_version.py)</vh></v>
<v t="lkj.20190808195546.4"><vh>get_keywords (_version.py)</vh></v>
<v t="lkj.20190808195546.5"><vh>class VersioneerConfig</vh></v>
<v t="lkj.20190808195546.6"><vh>get_config (_version.py)</vh></v>
<v t="lkj.20190808195546.7"><vh>class NotThisMethod(Exception)</vh></v>
<v t="lkj.20190808195546.8"><vh>register_vcs_handler (_version.py)</vh></v>
<v t="lkj.20190808195546.9"><vh>run_command (_version.py)</vh></v>
<v t="lkj.20190808195546.10"><vh>versions_from_parentdir (_version.py)</vh></v>
<v t="lkj.20190808195546.11"><vh>git_get_keywords (_version.py)</vh></v>
<v t="lkj.20190808195546.12"><vh>git_versions_from_keywords (_version.py)</vh></v>
<v t="lkj.20190808195546.13"><vh>git_pieces_from_vcs (_version.py)</vh></v>
<v t="lkj.20190808195546.14"><vh>plus_or_dot (_version.py)</vh></v>
<v t="lkj.20190808195546.15"><vh>render_pep440 (_version.py)</vh></v>
<v t="lkj.20190808195546.16"><vh>render_pep440_pre (_version.py)</vh></v>
<v t="lkj.20190808195546.17"><vh>render_pep440_post (_version.py)</vh></v>
<v t="lkj.20190808195546.18"><vh>render_pep440_old (_version.py)</vh></v>
<v t="lkj.20190808195546.19"><vh>render_git_describe (_version.py)</vh></v>
<v t="lkj.20190808195546.20"><vh>render_git_describe_long (_version.py)</vh></v>
<v t="lkj.20190808195546.21"><vh>render (_version.py)</vh></v>
<v t="lkj.20190808195546.22"><vh>get_versions (_version.py)</vh></v>
</v>
<v t="mhw.20190808085024.5"><vh>@clean base.py</vh>
<v t="mhw.20190808131212.23"><vh>Declarations (base.py)</vh></v>
<v t="mhw.20190808131212.24"><vh>class ShortCutter(object)</vh>
<v t="mhw.20190808131212.25"><vh>ShortCutter(object).__init__</vh></v>
<v t="mhw.20190808131212.26"><vh>ShortCutter(object)._set_win_vars</vh></v>
<v t="mhw.20190808131212.27"><vh>ShortCutter(object)._get_desktop_folder</vh></v>
<v t="mhw.20190808131212.28"><vh>ShortCutter(object)._get_menu_folder</vh></v>
<v t="mhw.20190808131212.29"><vh>ShortCutter(object)._get_bin_folder_pyexe</vh></v>
<v t="mhw.20190808131212.30"><vh>ShortCutter(object)._get_activate_wrapper_templates</vh></v>
<v t="mhw.20190808131212.31"><vh>ShortCutter(object)._make_executable</vh></v>
<v t="mhw.20190808131212.32"><vh>ShortCutter(object).exe</vh></v>
<v t="mhw.20190808131212.33"><vh>ShortCutter(object).ba</vh></v>
<v t="mhw.20190808131212.34"><vh>ShortCutter(object)._get_activate_args</vh></v>
<v t="mhw.20190808131212.35"><vh>ShortCutter(object)._check_if_conda_root</vh></v>
<v t="mhw.20190808131212.36"><vh>ShortCutter(object).create_desktop_shortcut</vh></v>
<v t="mhw.20190808131212.37"><vh>ShortCutter(object).create_menu_shortcut</vh></v>
<v t="mhw.20190808131212.38"><vh>ShortCutter(object)._path_to_name</vh></v>
<v t="mhw.20190808131212.39"><vh>ShortCutter(object)._ascii_name</vh></v>
<v t="mhw.20190808131212.40"><vh>ShortCutter(object)._create_wrapped_shortcut</vh></v>
<v t="mhw.20190808131212.41"><vh>ShortCutter(object).create_shortcut</vh></v>
<v t="mhw.20190808131212.42"><vh>ShortCutter(object)._safe_create</vh></v>
<v t="mhw.20190808131212.43"><vh>ShortCutter(object).create_shortcut_to_env_terminal</vh></v>
<v t="mhw.20190808131212.44"><vh>ShortCutter(object)._create_shortcut_to_dir</vh></v>
<v t="mhw.20190808131212.45"><vh>ShortCutter(object)._create_shortcut_file</vh></v>
<v t="mhw.20190808131212.46"><vh>ShortCutter(object).makedirs</vh></v>
<v t="mhw.20190808131212.47"><vh>ShortCutter(object).find_target</vh></v>
<v t="mhw.20190808131212.48"><vh>ShortCutter(object).search_for_target</vh></v>
<v t="mhw.20190808131212.49"><vh>ShortCutter(object)._is_file_the_target</vh></v>
<v t="mhw.20190808131212.50"><vh>ShortCutter(object)._get_paths</vh></v>
</v>
</v>
<v t="mhw.20190808085024.4"><vh>@clean exception.py</vh>
<v t="lkj.20190808195546.23"><vh>class ShortcutError(Exception)</vh></v>
<v t="lkj.20190808195546.24"><vh>class ShortcutNoDesktopError(ShortcutError)</vh></v>
<v t="lkj.20190808195546.25"><vh>class ShortcutNoMenuError(ShortcutError)</vh></v>
</v>
<v t="mhw.20190808085024.3"><vh>@clean linux.py</vh>
<v t="lkj.20190808195546.26"><vh>Declarations (linux.py)</vh></v>
<v t="lkj.20190808195546.27"><vh>class ShortCutterLinux(ShortCutter)</vh>
<v t="lkj.20190808195546.28"><vh>ShortCutterLinux(ShortCutter)._get_desktop_folder</vh></v>
<v t="lkj.20190808195546.29"><vh>ShortCutterLinux(ShortCutter)._get_menu_folder</vh></v>
<v t="lkj.20190808195546.30"><vh>ShortCutterLinux(ShortCutter)._get_bin_folder_pyexe</vh></v>
<v t="lkj.20190808195546.31"><vh>ShortCutterLinux(ShortCutter)._get_activate_wrapper_templates</vh></v>
<v t="lkj.20190808195546.32"><vh>ShortCutterLinux(ShortCutter)._make_executable</vh></v>
<v t="lkj.20190808195546.33"><vh>ShortCutterLinux(ShortCutter)._create_shortcut_to_dir</vh></v>
<v t="lkj.20190808195546.34"><vh>ShortCutterLinux(ShortCutter)._create_shortcut_file</vh></v>
<v t="lkj.20190808195546.35"><vh>ShortCutterLinux(ShortCutter)._create_shortcut_linux</vh></v>
<v t="lkj.20190808195546.36"><vh>ShortCutterLinux(ShortCutter)._is_file_the_target</vh></v>
<v t="lkj.20190808195546.37"><vh>ShortCutterLinux(ShortCutter)._get_paths</vh></v>
</v>
</v>
<v t="mhw.20190808085024.2"><vh>@clean macos.py</vh>
<v t="lkj.20190808195546.38"><vh>Declarations (macos.py)</vh></v>
<v t="lkj.20190808195546.39"><vh>create_shortcut (macos.py)</vh></v>
<v t="lkj.20190808195546.40"><vh>class ShortCutterMacOS(ShortCutterLinux)</vh>
<v t="lkj.20190808195546.41"><vh>ShortCutterMacOS(ShortCutterLinux)._get_desktop_folder</vh></v>
<v t="lkj.20190808195546.42"><vh>ShortCutterMacOS(ShortCutterLinux)._get_menu_folder</vh></v>
<v t="lkj.20190808195546.43"><vh>ShortCutterMacOS(ShortCutterLinux)._create_shortcut_to_dir</vh></v>
<v t="lkj.20190808195546.44"><vh>ShortCutterMacOS(ShortCutterLinux)._create_shortcut_file</vh></v>
</v>
</v>
<v t="mhw.20190808085024.1"><vh>@clean windows.py</vh>
<v t="mhw.20190808135317.46"><vh>Declarations (windows.py)</vh></v>
<v t="mhw.20190808135317.47"><vh>class ShortCutterWindows(ShortCutter)</vh>
<v t="mhw.20190808135317.48"><vh>ShortCutterWindows(ShortCutter)._set_win_vars</vh></v>
<v t="mhw.20190808135317.49"><vh>ShortCutterWindows(ShortCutter)._get_desktop_folder</vh></v>
<v t="mhw.20190808135317.50"><vh>ShortCutterWindows(ShortCutter)._get_menu_folder</vh></v>
<v t="mhw.20190808135317.51"><vh>ShortCutterWindows(ShortCutter)._get_bin_folder_pyexe</vh></v>
<v t="mhw.20190808135317.52"><vh>ShortCutterWindows(ShortCutter)._get_activate_wrapper_templates</vh></v>
<v t="mhw.20190808135317.53"><vh>ShortCutterWindows(ShortCutter)._make_executable</vh></v>
<v t="mhw.20190808135317.54"><vh>ShortCutterWindows(ShortCutter)._create_shortcut_to_dir</vh></v>
<v t="mhw.20190808135317.55"><vh>ShortCutterWindows(ShortCutter)._create_shortcut_file</vh></v>
<v t="mhw.20190808135317.56"><vh>ShortCutterWindows(ShortCutter)._create_shortcut_win</vh></v>
<v t="mhw.20190808135317.57"><vh>ShortCutterWindows(ShortCutter)._is_file_the_target</vh></v>
<v t="mhw.20190808135317.58"><vh>ShortCutterWindows(ShortCutter)._get_paths</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="mhw.20190808090216.1"><vh>modified</vh>
<v t="mhw.20190808131212.41"></v>
<v t="mhw.20190808131212.42"></v>
<v t="mhw.20190808135317.56"></v>
<v t="mhw.20190808131212.36"></v>
<v t="mhw.20190808131212.37"></v>
</v>
<v t="mhw.20190808140641.1"><vh>Found:_create_shortcut_win</vh>
<v t="mhw.20190808135317.55"></v>
<v t="mhw.20190808135317.54"></v>
<v t="mhw.20190808135317.56"></v>
</v>
<v t="mhw.20190808141042.1"><vh>Found:_create_shortcut_file</vh>
<v t="mhw.20190808131212.45"></v>
<v t="mhw.20190808131212.40"></v>
<v t="mhw.20190808131212.41"></v>
<v t="mhw.20190808135317.35"><vh>ShortCutterLinux(ShortCutter)._create_shortcut_file</vh></v>
<v t="mhw.20190808135317.45"><vh>ShortCutterMacOS(ShortCutterLinux)._create_shortcut_file</vh></v>
<v t="mhw.20190808135317.55"></v>
</v>
</vnodes>
<tnodes>
<t tx="lkj.20190808195546.1">from ._version import get_versions
__version__ = get_versions()['version']
del get_versions

import os
import sys

# operating system specific imports
if os.name == 'nt':
    from .windows import ShortCutterWindows as ShortCutter
elif os.name == 'posix':
    if sys.platform == 'darwin':
        from .macos import ShortCutterMacOS as ShortCutter
    else:
        from .linux import ShortCutterLinux as ShortCutter
else:
    raise Exception("Error: '{}' platform is not supported.".format(sys.platform))


</t>
<t tx="lkj.20190808195546.10">def versions_from_parentdir(parentdir_prefix, root, verbose):
    """Try to determine the version from the parent directory name.

    Source tarballs conventionally unpack into a directory that includes
    both the project name and a version string.
    """
    dirname = os.path.basename(root)
    if not dirname.startswith(parentdir_prefix):
        if verbose:
            print("guessing rootdir is '%s', but '%s' doesn't start with "
                  "prefix '%s'" % (root, dirname, parentdir_prefix))
        raise NotThisMethod("rootdir doesn't start with parentdir_prefix")
    return {"version": dirname[len(parentdir_prefix):],
            "full-revisionid": None,
            "dirty": False, "error": None}


</t>
<t tx="lkj.20190808195546.11">@register_vcs_handler("git", "get_keywords")
def git_get_keywords(versionfile_abs):
    """Extract version information from the given file."""
    # the code embedded in _version.py can just fetch the value of these
    # keywords. When used from setup.py, we don't want to import _version.py,
    # so we do it with a regexp instead. This function is not used from
    # _version.py.
    keywords = {}
    try:
        f = open(versionfile_abs, "r")
        for line in f.readlines():
            if line.strip().startswith("git_refnames ="):
                mo = re.search(r'=\s*"(.*)"', line)
                if mo:
                    keywords["refnames"] = mo.group(1)
            if line.strip().startswith("git_full ="):
                mo = re.search(r'=\s*"(.*)"', line)
                if mo:
                    keywords["full"] = mo.group(1)
        f.close()
    except EnvironmentError:
        pass
    return keywords


</t>
<t tx="lkj.20190808195546.12">@register_vcs_handler("git", "keywords")
def git_versions_from_keywords(keywords, tag_prefix, verbose):
    """Get version information from git keywords."""
    if not keywords:
        raise NotThisMethod("no keywords at all, weird")
    refnames = keywords["refnames"].strip()
    if refnames.startswith("$Format"):
        if verbose:
            print("keywords are unexpanded, not using")
        raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
    refs = set([r.strip() for r in refnames.strip("()").split(",")])
    # starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
    # just "foo-1.0". If we see a "tag: " prefix, prefer those.
    TAG = "tag: "
    tags = set([r[len(TAG):] for r in refs if r.startswith(TAG)])
    if not tags:
        # Either we're using git &lt; 1.8.3, or there really are no tags. We use
        # a heuristic: assume all version tags have a digit. The old git %d
        # expansion behaves like git log --decorate=short and strips out the
        # refs/heads/ and refs/tags/ prefixes that would let us distinguish
        # between branches and tags. By ignoring refnames without digits, we
        # filter out many common branch names like "release" and
        # "stabilization", as well as "HEAD" and "master".
        tags = set([r for r in refs if re.search(r'\d', r)])
        if verbose:
            print("discarding '%s', no digits" % ",".join(refs-tags))
    if verbose:
        print("likely tags: %s" % ",".join(sorted(tags)))
    for ref in sorted(tags):
        # sorting will prefer e.g. "2.0" over "2.0rc1"
        if ref.startswith(tag_prefix):
            r = ref[len(tag_prefix):]
            if verbose:
                print("picking %s" % r)
            return {"version": r,
                    "full-revisionid": keywords["full"].strip(),
                    "dirty": False, "error": None
                    }
    # no suitable tags, so version is "0+unknown", but full hex is still there
    if verbose:
        print("no suitable tags, using unknown + full revision id")
    return {"version": "0+unknown",
            "full-revisionid": keywords["full"].strip(),
            "dirty": False, "error": "no suitable tags"}


</t>
<t tx="lkj.20190808195546.13">@register_vcs_handler("git", "pieces_from_vcs")
def git_pieces_from_vcs(tag_prefix, root, verbose, run_command=run_command):
    """Get version from 'git describe' in the root of the source tree.

    This only gets called if the git-archive 'subst' keywords were *not*
    expanded, and _version.py hasn't already been rewritten with a short
    version string, meaning we're inside a checked out source tree.
    """
    if not os.path.exists(os.path.join(root, ".git")):
        if verbose:
            print("no .git in %s" % root)
        raise NotThisMethod("no .git directory")

    GITS = ["git"]
    if sys.platform == "win32":
        GITS = ["git.cmd", "git.exe"]
    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]
    # if there isn't one, this yields HEX[-dirty] (no NUM)
    describe_out = run_command(GITS, ["describe", "--tags", "--dirty",
                                      "--always", "--long",
                                      "--match", "%s*" % tag_prefix],
                               cwd=root)
    # --long was added in git-1.5.5
    if describe_out is None:
        raise NotThisMethod("'git describe' failed")
    describe_out = describe_out.strip()
    full_out = run_command(GITS, ["rev-parse", "HEAD"], cwd=root)
    if full_out is None:
        raise NotThisMethod("'git rev-parse' failed")
    full_out = full_out.strip()

    pieces = {}
    pieces["long"] = full_out
    pieces["short"] = full_out[:7]  # maybe improved later
    pieces["error"] = None

    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]
    # TAG might have hyphens.
    git_describe = describe_out

    # look for -dirty suffix
    dirty = git_describe.endswith("-dirty")
    pieces["dirty"] = dirty
    if dirty:
        git_describe = git_describe[:git_describe.rindex("-dirty")]

    # now we have TAG-NUM-gHEX or HEX

    if "-" in git_describe:
        # TAG-NUM-gHEX
        mo = re.search(r'^(.+)-(\d+)-g([0-9a-f]+)$', git_describe)
        if not mo:
            # unparseable. Maybe git-describe is misbehaving?
            pieces["error"] = ("unable to parse git-describe output: '%s'"
                               % describe_out)
            return pieces

        # tag
        full_tag = mo.group(1)
        if not full_tag.startswith(tag_prefix):
            if verbose:
                fmt = "tag '%s' doesn't start with prefix '%s'"
                print(fmt % (full_tag, tag_prefix))
            pieces["error"] = ("tag '%s' doesn't start with prefix '%s'"
                               % (full_tag, tag_prefix))
            return pieces
        pieces["closest-tag"] = full_tag[len(tag_prefix):]

        # distance: number of commits since tag
        pieces["distance"] = int(mo.group(2))

        # commit: short hex revision ID
        pieces["short"] = mo.group(3)

    else:
        # HEX: no tags
        pieces["closest-tag"] = None
        count_out = run_command(GITS, ["rev-list", "HEAD", "--count"],
                                cwd=root)
        pieces["distance"] = int(count_out)  # total number of commits

    return pieces


</t>
<t tx="lkj.20190808195546.14">def plus_or_dot(pieces):
    """Return a + if we don't already have one, else return a ."""
    if "+" in pieces.get("closest-tag", ""):
        return "."
    return "+"


</t>
<t tx="lkj.20190808195546.15">def render_pep440(pieces):
    """Build up version string, with post-release "local version identifier".

    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you
    get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty

    Exceptions:
    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]
    """
    if pieces["closest-tag"]:
        rendered = pieces["closest-tag"]
        if pieces["distance"] or pieces["dirty"]:
            rendered += plus_or_dot(pieces)
            rendered += "%d.g%s" % (pieces["distance"], pieces["short"])
            if pieces["dirty"]:
                rendered += ".dirty"
    else:
        # exception #1
        rendered = "0+untagged.%d.g%s" % (pieces["distance"],
                                          pieces["short"])
        if pieces["dirty"]:
            rendered += ".dirty"
    return rendered


</t>
<t tx="lkj.20190808195546.16">def render_pep440_pre(pieces):
    """TAG[.post.devDISTANCE] -- No -dirty.

    Exceptions:
    1: no tags. 0.post.devDISTANCE
    """
    if pieces["closest-tag"]:
        rendered = pieces["closest-tag"]
        if pieces["distance"]:
            rendered += ".post.dev%d" % pieces["distance"]
    else:
        # exception #1
        rendered = "0.post.dev%d" % pieces["distance"]
    return rendered


</t>
<t tx="lkj.20190808195546.17">def render_pep440_post(pieces):
    """TAG[.postDISTANCE[.dev0]+gHEX] .

    The ".dev0" means dirty. Note that .dev0 sorts backwards
    (a dirty tree will appear "older" than the corresponding clean one),
    but you shouldn't be releasing software with -dirty anyways.

    Exceptions:
    1: no tags. 0.postDISTANCE[.dev0]
    """
    if pieces["closest-tag"]:
        rendered = pieces["closest-tag"]
        if pieces["distance"] or pieces["dirty"]:
            rendered += ".post%d" % pieces["distance"]
            if pieces["dirty"]:
                rendered += ".dev0"
            rendered += plus_or_dot(pieces)
            rendered += "g%s" % pieces["short"]
    else:
        # exception #1
        rendered = "0.post%d" % pieces["distance"]
        if pieces["dirty"]:
            rendered += ".dev0"
        rendered += "+g%s" % pieces["short"]
    return rendered


</t>
<t tx="lkj.20190808195546.18">def render_pep440_old(pieces):
    """TAG[.postDISTANCE[.dev0]] .

    The ".dev0" means dirty.

    Eexceptions:
    1: no tags. 0.postDISTANCE[.dev0]
    """
    if pieces["closest-tag"]:
        rendered = pieces["closest-tag"]
        if pieces["distance"] or pieces["dirty"]:
            rendered += ".post%d" % pieces["distance"]
            if pieces["dirty"]:
                rendered += ".dev0"
    else:
        # exception #1
        rendered = "0.post%d" % pieces["distance"]
        if pieces["dirty"]:
            rendered += ".dev0"
    return rendered


</t>
<t tx="lkj.20190808195546.19">def render_git_describe(pieces):
    """TAG[-DISTANCE-gHEX][-dirty].

    Like 'git describe --tags --dirty --always'.

    Exceptions:
    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
    """
    if pieces["closest-tag"]:
        rendered = pieces["closest-tag"]
        if pieces["distance"]:
            rendered += "-%d-g%s" % (pieces["distance"], pieces["short"])
    else:
        # exception #1
        rendered = pieces["short"]
    if pieces["dirty"]:
        rendered += "-dirty"
    return rendered


</t>
<t tx="lkj.20190808195546.2">def main():
    from argparse import ArgumentParser

    parser = ArgumentParser(description="Automatic shortcut creator." +
                                        " Shortcuts auto-activate their environments by default.")
    parser.add_argument("target", nargs='?', default=None,
                        help="The target executable to create Desktop and Menu shortcuts.")
    parser.add_argument("-d", "--desktop", action="store_true", help="Only create a desktop shortcut.")
    parser.add_argument("-m", "--menu", action="store_true", help="Only create a menu shortcut.")
    parser.add_argument("-n", "--name", nargs='?', default=None, help="Name of the shortcut without extension (autoname otherwise).")
    parser.add_argument("-s", "--simple", action="store_true", help="Create simple shortcut without activate wrapper.")
    parser.add_argument("-t", "--terminal", action="store_true",
                        help="Create shortcut to environment with shortcutter " +
                             "(plus shortcut to root environment in case of conda).")
    args = parser.parse_args()

    create_desktop = args.desktop
    create_menu = args.menu
    activate = not args.simple
    name = args.name if args.name else None

    if not args.target and not args.terminal:
        print('Shortcutter needs target or --terminal arguments to work.')
        return

    # if desktop or menu hasnt been specified create both (i.e. the default)
    if not create_desktop and not create_menu:
        create_desktop = True
        create_menu = True

    sc = ShortCutter(activate=activate, error_log=sys.stdout)

    target_path = sc.find_target(args.target)
    if target_path or args.terminal:

        desktop_created = False
        if create_desktop:
            if args.terminal:
                desktop_created = sc.create_shortcut_to_env_terminal(name, menu=False)
            else:
                ret = sc.create_desktop_shortcut(target_path, name)
                desktop_created = bool(ret[2])  # shortcut_path = ret[2]
            if not desktop_created:
                print("Failed to create desktop shortcut.")

        menu_created = False
        if create_menu:
            if args.terminal:
                menu_created = sc.create_shortcut_to_env_terminal(name, desktop=False)
            else:
                ret = sc.create_menu_shortcut(target_path, name)
                menu_created = bool(ret[2])  # shortcut_path = ret[2]
            if not menu_created:
                print("Failed to create menu shortcut.")

        msg = "created for '{}'.".format(args.target if not args.terminal else 'terminal at environment')
        if desktop_created and menu_created:
            print('Desktop and menu shortcuts were ' + msg)
        elif desktop_created and not menu_created:
            print('Desktop shortcut was ' + msg)
        elif not desktop_created and menu_created:
            print('Menu shortcut was ' + msg)
    else:
        print("Shortcut creation failed: unable to find '{}'.".format(args.target))
</t>
<t tx="lkj.20190808195546.20">def render_git_describe_long(pieces):
    """TAG-DISTANCE-gHEX[-dirty].

    Like 'git describe --tags --dirty --always -long'.
    The distance/hash is unconditional.

    Exceptions:
    1: no tags. HEX[-dirty]  (note: no 'g' prefix)
    """
    if pieces["closest-tag"]:
        rendered = pieces["closest-tag"]
        rendered += "-%d-g%s" % (pieces["distance"], pieces["short"])
    else:
        # exception #1
        rendered = pieces["short"]
    if pieces["dirty"]:
        rendered += "-dirty"
    return rendered


</t>
<t tx="lkj.20190808195546.21">def render(pieces, style):
    """Render the given version pieces into the requested style."""
    if pieces["error"]:
        return {"version": "unknown",
                "full-revisionid": pieces.get("long"),
                "dirty": None,
                "error": pieces["error"]}

    if not style or style == "default":
        style = "pep440"  # the default

    if style == "pep440":
        rendered = render_pep440(pieces)
    elif style == "pep440-pre":
        rendered = render_pep440_pre(pieces)
    elif style == "pep440-post":
        rendered = render_pep440_post(pieces)
    elif style == "pep440-old":
        rendered = render_pep440_old(pieces)
    elif style == "git-describe":
        rendered = render_git_describe(pieces)
    elif style == "git-describe-long":
        rendered = render_git_describe_long(pieces)
    else:
        raise ValueError("unknown style '%s'" % style)

    return {"version": rendered, "full-revisionid": pieces["long"],
            "dirty": pieces["dirty"], "error": None}


</t>
<t tx="lkj.20190808195546.22">def get_versions():
    """Get version information or return default if unable to do so."""
    # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have
    # __file__, we can work backwards from there to the root. Some
    # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which
    # case we can only use expanded keywords.

    cfg = get_config()
    verbose = cfg.verbose

    try:
        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix,
                                          verbose)
    except NotThisMethod:
        pass

    try:
        root = os.path.realpath(__file__)
        # versionfile_source is the relative path from the top of the source
        # tree (where the .git directory might live) to this file. Invert
        # this to find the root from __file__.
        for i in cfg.versionfile_source.split('/'):
            root = os.path.dirname(root)
    except NameError:
        return {"version": "0+unknown", "full-revisionid": None,
                "dirty": None,
                "error": "unable to find root of source tree"}

    try:
        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)
        return render(pieces, cfg.style)
    except NotThisMethod:
        pass

    try:
        if cfg.parentdir_prefix:
            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)
    except NotThisMethod:
        pass

    return {"version": "0+unknown", "full-revisionid": None,
            "dirty": None,
            "error": "unable to compute version"}
</t>
<t tx="lkj.20190808195546.23">class ShortcutError(Exception):
    pass


</t>
<t tx="lkj.20190808195546.24">class ShortcutNoDesktopError(ShortcutError):
    pass


</t>
<t tx="lkj.20190808195546.25">class ShortcutNoMenuError(ShortcutError):
    pass
</t>
<t tx="lkj.20190808195546.26">import sys
import os
from os import path as p
import stat
from .base import ShortCutter

ACTIVATE = """#!/bin/bash
export PYTHONNOUSERSITE=1
source "{activate}"
"{executable}" "$@"
source "{bin}/deactivate"
"""

ACTIVATE_PROMPT = """#!/bin/bash
bash --rcfile &lt;(echo 'export PATH="{bin}:$PATH"; export PYTHONNOUSERSITE=1; source "{activate}"; cd $HOME')
"""


</t>
<t tx="lkj.20190808195546.27">class ShortCutterLinux(ShortCutter):
    @others
</t>
<t tx="lkj.20190808195546.28">@staticmethod
def _get_desktop_folder():
    import subprocess
    try:
        return subprocess.check_output(['xdg-user-dir',
                                        'DESKTOP']).decode('utf-8').strip()
    except Exception:
        return p.join(p.expanduser('~'), 'Desktop')

</t>
<t tx="lkj.20190808195546.29">@staticmethod
def _get_menu_folder():
    return p.join(p.expanduser('~'), '.local', 'share', 'applications')

</t>
<t tx="lkj.20190808195546.3">"""Git implementation of _version.py."""

import errno
import os
import re
import subprocess
import sys


</t>
<t tx="lkj.20190808195546.30">@staticmethod
def _get_bin_folder_pyexe():
    return p.dirname(sys.executable)

</t>
<t tx="lkj.20190808195546.31">@staticmethod
def _get_activate_wrapper_templates():
    return ACTIVATE, ACTIVATE_PROMPT

</t>
<t tx="lkj.20190808195546.32">@staticmethod
def _make_executable(file_path):
    st = os.stat(file_path)
    os.chmod(file_path, st.st_mode | stat.S_IEXEC)

</t>
<t tx="lkj.20190808195546.33">def _create_shortcut_to_dir(self, shortcut_name, target_path, shortcut_directory):
    """
    Creates a Linux shortcut file to executable.
    """
    return self._create_shortcut_linux(shortcut_name, target_path, shortcut_directory,
                                       '[Desktop Entry]\n' +
                                       'Name={}\n'.format(shortcut_name) +
                                       'Type=Application\n' +
                                       'Path={}\n'.format(target_path) +
                                       'Exec=xdg-open "{}"\n'.format(target_path) +
                                       'Icon=system-file-manager.png\n')

</t>
<t tx="lkj.20190808195546.34">def _create_shortcut_file(self, shortcut_name, target_path, shortcut_directory):
    """
    Creates a Linux shortcut file to folder.
    """
    return self._create_shortcut_linux(shortcut_name, target_path, shortcut_directory,
                                       '[Desktop Entry]\n' +
                                       'Name={}\n'.format(shortcut_name) +
                                       'Type=Application\n' +
                                       'Exec="{}" %F\n'.format(target_path) +
                                       'Terminal=true\n')

</t>
<t tx="lkj.20190808195546.35">def _create_shortcut_linux(self, shortcut_name, target_path, shortcut_directory, script):
    """
    Creates a Linux shortcut file using .desktop file script

    Returns tuple (shortcut_name, target_path, shortcut_file_path)
    """
    shortcut_file_path = p.join(shortcut_directory, shortcut_name + '.desktop')

    with open(shortcut_file_path, "w") as shortcut:
        shortcut.write(script)
        self._make_executable(shortcut_file_path)

    return shortcut_name, target_path, shortcut_file_path

</t>
<t tx="lkj.20190808195546.36">def _is_file_the_target(self, target, file_name, file_path):
    match = False
    if file_name == target:
        # is the file executable
        if os.access(file_path, os.X_OK):
            match = True
        else:
            match = False
    return match

</t>
<t tx="lkj.20190808195546.37">@staticmethod
def _get_paths():
    """
    Gets paths from the PATH environment variable and
    prepends the `&lt;Python&gt;/bin` directory.

    Returns a list of paths.
    """
    return [p.dirname(sys.executable)] + os.environ['PATH'].split(os.pathsep) + [p.join(p.expanduser('~'), '.local', 'bin')]
</t>
<t tx="lkj.20190808195546.38">from os import path as p
from .exception import ShortcutError
from .linux import ShortCutterLinux
from tempfile import NamedTemporaryFile
import subprocess as sp


</t>
<t tx="lkj.20190808195546.39">def create_shortcut(shortcut_name, target_path, shortcut_directory, script):
    """
    Creates a MacOS app which opens an target_path (executable or folder) using AppleScript script

    Returns tuple (shortcut_name, target_path, shortcut_file_path)
    """
    shortcut_file_path = p.join(shortcut_directory, shortcut_name + ".app")

    # create the AppleScript script
    sf = NamedTemporaryFile(mode="w")
    sf.write(script)
    sf.flush()

    # compile the script into an application
    proc = sp.Popen(["osacompile", "-o", shortcut_file_path, sf.name],
                    stdout=sp.PIPE, stderr=sp.PIPE)
    out, err = proc.communicate()
    if err or (proc.returncode != 0):
        raise ShortcutError(
            "Error occured creating app. Return code: {}, Error message: {}".format(
                proc.returncode,
                err.decode()
            ))

    sf.close()

    return shortcut_name, target_path, shortcut_file_path


</t>
<t tx="lkj.20190808195546.4">def get_keywords():
    """Get the keywords needed to look up the version information."""
    # these strings will be replaced by git during git-archive.
    # setup.py/versioneer.py will grep for the variable names, so they must
    # each be defined on a line of their own. _version.py will just call
    # get_keywords().
    git_refnames = "$Format:%d$"
    git_full = "$Format:%H$"
    keywords = {"refnames": git_refnames, "full": git_full}
    return keywords


</t>
<t tx="lkj.20190808195546.40">class ShortCutterMacOS(ShortCutterLinux):
    @others
</t>
<t tx="lkj.20190808195546.41">@staticmethod
def _get_desktop_folder():
    return p.join(p.expanduser('~'), 'Desktop')

</t>
<t tx="lkj.20190808195546.42">@staticmethod
def _get_menu_folder():
    return p.join('/', 'Applications') 

</t>
<t tx="lkj.20190808195546.43">def _create_shortcut_to_dir(self, shortcut_name, target_path, shortcut_directory):
    """
    Creates a MacOS app which opens a folder via finder
    """
    return create_shortcut(shortcut_name, target_path, shortcut_directory,
                           'tell application "Finder"\n' +
                           'open POSIX file "{}"\n'.format(target_path) +
                           'end tell\n')

</t>
<t tx="lkj.20190808195546.44">def _create_shortcut_file(self, shortcut_name, target_path, shortcut_directory):
    """
    Creates a MacOS app which opens an executable via the terminal
    """
    return create_shortcut(shortcut_name, target_path, shortcut_directory,
                           'tell application "Terminal"\n' +
                           'activate\n' +
                           'do script "{}"\n'.format(target_path) +
                           'end tell\n')
</t>
<t tx="lkj.20190808195546.5">class VersioneerConfig:
    """Container for Versioneer configuration parameters."""


</t>
<t tx="lkj.20190808195546.6">def get_config():
    """Create, populate and return the VersioneerConfig() object."""
    # these strings are filled in when 'setup.py versioneer' creates
    # _version.py
    cfg = VersioneerConfig()
    cfg.VCS = "git"
    cfg.style = "pep440"
    cfg.tag_prefix = ""
    cfg.parentdir_prefix = "None"
    cfg.versionfile_source = "shortcutter/_version.py"
    cfg.verbose = False
    return cfg


</t>
<t tx="lkj.20190808195546.7">class NotThisMethod(Exception):
    """Exception raised if a method is not valid for the current scenario."""


LONG_VERSION_PY = {}
HANDLERS = {}


</t>
<t tx="lkj.20190808195546.8">def register_vcs_handler(vcs, method):  # decorator
    """Decorator to mark a method as the handler for a particular VCS."""
    def decorate(f):
        """Store f in HANDLERS[vcs][method]."""
        if vcs not in HANDLERS:
            HANDLERS[vcs] = {}
        HANDLERS[vcs][method] = f
        return f
    return decorate


</t>
<t tx="lkj.20190808195546.9">def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False):
    """Call the given command(s)."""
    assert isinstance(commands, list)
    p = None
    for c in commands:
        try:
            dispcmd = str([c] + args)
            # remember shell=False, so use git.cmd on windows, not just git
            p = subprocess.Popen([c] + args, cwd=cwd, stdout=subprocess.PIPE,
                                 stderr=(subprocess.PIPE if hide_stderr
                                         else None))
            break
        except EnvironmentError:
            e = sys.exc_info()[1]
            if e.errno == errno.ENOENT:
                continue
            if verbose:
                print("unable to run %s" % dispcmd)
                print(e)
            return None
    else:
        if verbose:
            print("unable to find command, tried %s" % (commands,))
        return None
    stdout = p.communicate()[0].strip()
    if sys.version_info[0] &gt;= 3:
        stdout = stdout.decode()
    if p.returncode != 0:
        if verbose:
            print("unable to run %s (error)" % dispcmd)
        return None
    return stdout


</t>
<t tx="mhw.20190808084549.2">Easy cross-platform creation of shortcuts supporting virtual and Anaconda environments

Upstream: https://github.com/kiwi0fruit/shortcutter
My fork: https://github.com/maphew/shortcutter.git


@path ../shortcutter
</t>
<t tx="mhw.20190808085013.1"></t>
<t tx="mhw.20190808085024.1">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190808085024.2">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190808085024.3">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190808085024.4">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190808085024.5">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190808085024.6">
# This file helps to compute a version number in source trees obtained from
# git-archive tarball (such as those provided by githubs download-from-tag
# feature). Distribution tarballs (built by setup.py sdist) and build
# directories (produced by setup.py build) will contain a much shorter file
# that just contains the computed version number.

# This file is released into the public domain. Generated by
# versioneer-0.16 (https://github.com/warner/python-versioneer)

@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190808085024.7">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190808090216.1">@language python
@tabwidth -4
</t>
<t tx="mhw.20190808092452.12">@path shortcutter</t>
<t tx="mhw.20190808092452.14">@path docs</t>
<t tx="mhw.20190808092452.15">@path conda-forge</t>
<t tx="mhw.20190808131212.23">import os
import sys
from os import path as p
from .exception import ShortcutError, ShortcutNoDesktopError, ShortcutNoMenuError
import re
import traceback


</t>
<t tx="mhw.20190808131212.24">class ShortCutter(object):
    """
    Creates applicaton shortcuts for Windows, MacOS and Linux operating systems.

    To create desktop and menu shortcuts to ``python``::

        from shortcutter import ShortCutter
        s = ShortCutter()
        s.create_desktop_shortcut("python")
        s.create_menu_shortcut("python")

    Attributes:
    -----------
    raise_errors : bool=False
        Whether to raise exceptions or skip errors and continue.
    error_log : object=None
        File object where to write errors when ``raise_errors=False``.
        Default is None - do not write errors.
        Can also be ``sys.stderr`` or ``io.StringIO()``.
    desktop_folder : str
        Directory used when creating desktop shortcuts.
    menu_folder : str
        Directory used when creating menu shortcuts.
    bin_folder_pyexe : str
        ``Scripts`` or ``bin`` dir path. Simply closest to python executable path.
    bin_folder_shcut : str or None
        ``Scripts`` or ``bin`` dir path where shortcutter executable was installed.
    local_root : str
        Root directory path of the current python environment / installation.
        Derived from python executable path.
    activate : bool=True
        Whether to create shortcuts that automatically activate
        conda environment / virtual environment.
    exists : bool=True
        Whether the target should exist or not.
        If not then add ``/`` (``\\`` on Windows) at the end of the path to get dir shortcut.
    activate_args : tuple (str or None, str or None)
        First is the activate script full path (or None if it's wasn't found) - conda's or venv's.
        Second is the env argument of the activate script (or None if not needed).
    """

    @others
</t>
<t tx="mhw.20190808131212.25">def __init__(self, raise_errors=False, error_log=None, activate=True, exists=True):
    """
    Creates ShortCutter.

    Parameters
    ----------
    raise_errors : bool=False
        Whether to raise exceptions or skip errors and continue.
    error_log : object=None
        File object where to write errors when ``raise_errors=False``.
        Default is None - do not write errors.
        Can also be ``sys.stderr`` or ``io.StringIO()``.
    activate : bool=True
        Whether to create shortcuts that automatically activate
        conda environment / virtual environment.
    exists : bool=True
        Whether the target should exist or not.
        If not then add ``/`` (``\\`` on Windows) at the end of the path to get dir shortcut.
    """
    self._set_win_vars()  # important on Windows

    self.raise_errors = raise_errors
    self.error_log = error_log
    self.activate = activate
    self.exists = exists
    self.desktop_folder = self._get_desktop_folder()
    self.menu_folder = self._get_menu_folder()
    self.bin_folder_pyexe = self._get_bin_folder_pyexe()
    shortcutter = self.find_target('shortcutter')
    self.bin_folder_shcut = p.dirname(shortcutter) if shortcutter else self.bin_folder_pyexe
    self.local_root = sys.prefix
    self._ACTIVATE, self._ACTIVATE_PROMPT = self._get_activate_wrapper_templates()

    self.activate_args = self._get_activate_args()  # should be run the last

# might be overridden if needed
</t>
<t tx="mhw.20190808131212.26">def _set_win_vars(self):
    pass

# should be overridden
</t>
<t tx="mhw.20190808131212.27">@staticmethod
def _get_desktop_folder():
    raise ShortcutError("_get_desktop_folder needs overriding")

# should be overridden
</t>
<t tx="mhw.20190808131212.28">@staticmethod
def _get_menu_folder():
    raise ShortcutError("_get_menu_folder needs overriding")

# should be overridden
</t>
<t tx="mhw.20190808131212.29">@staticmethod
def _get_bin_folder_pyexe():
    raise ShortcutError("_get_bin_folder_pyexe needs overriding")

# should be overridden
</t>
<t tx="mhw.20190808131212.30">@staticmethod
def _get_activate_wrapper_templates():
    raise ShortcutError("_get_activate_wrapper_templates needs overriding")

# should be overridden
</t>
<t tx="mhw.20190808131212.31">@staticmethod
def _make_executable(file_path):
    raise ShortcutError("_make_executable needs overriding")

</t>
<t tx="mhw.20190808131212.32">def exe(self, app_name):
    """
    Returns platform independent executable name:

    * app &gt; app (on Unix)
    * app &gt; app.exe (on Windows)
    """
    if os.name == 'nt':
        return app_name + '.exe'
    else:
        return app_name

</t>
<t tx="mhw.20190808131212.33">def ba(self, script_name):
    """
    Returns platform independent shell script (bash/batch) name:

    * run &gt; run (on Unix)
    * run &gt; run.bat (on Windows)
    """
    if os.name == 'nt':
        return script_name + '.bat'
    else:
        return script_name

</t>
<t tx="mhw.20190808131212.34">def _get_activate_args(self):
    """
    Returns tuple: (str or None, str or None).

    First is the activate script full path (or None if it's wasn't found) - conda's or venv's.

    Second is the env argument of the activate script (or None if not needed).
    """
    if p.isdir(p.join(self.local_root, 'conda-meta')):
        # check if we are installing to conda root:
        activate = self._check_if_conda_root(self.local_root)
        if activate:
            return activate, None

        # check if we are installing to default conda env location:
        #   `&lt;conda_root&gt;/envs/&lt;local_root_basename&gt;`
        ddot = p.dirname(self.local_root)
        activate = self._check_if_conda_root(p.dirname(ddot))
        if (p.basename(ddot) == 'envs') and activate: 
            return activate, p.basename(self.local_root)

        # check if we are running pip via `conda env create -f env.yaml`
        #   or user specified `CONDA_ROOT` env var himself:
        conda_root = os.environ.get('CONDA_ROOT')
        activate = self._check_if_conda_root(conda_root)
        if activate:
            if p.isabs(conda_root):
                return activate, self.local_root

        # check if there is conda in the PATH:
        conda = self.find_target('conda')
        if conda is not None:
            conda_root = p.dirname(p.dirname(conda))
            activate = self._check_if_conda_root(conda_root)
            if activate:
                return activate, self.local_root

        return None, self.local_root
    else:
        # check if we are installing to venv:
        activate = p.join(self.bin_folder_pyexe, self.ba('activate'))
        if p.isfile(activate):
            return activate, None

    return None, None
 
</t>
<t tx="mhw.20190808131212.35">def _check_if_conda_root(self, path):
    """
    Checks if provided path is conda root. It should have
    conda-meta folder, conda executable, activate shell script.

    Returns path to conda activate script or None.
    """
    if path is not None:
        if p.isdir(p.join(path, 'conda-meta')):
            conda = p.join(path,
                           p.basename(self.bin_folder_pyexe),
                           self.exe('conda'))
            # check if the file executable:
            if p.isfile(conda) and os.access(conda, os.X_OK):
                activate = p.join(p.dirname(conda), self.ba('activate'))
                if p.isfile(activate):
                    return p.abspath(activate)
    return None

</t>
<t tx="mhw.20190808131212.36">def create_desktop_shortcut(self, target, shortcut_name=None, icon=None):
    """
    Creates a desktop shortcut to a target.

    Parameters
    ----------
    target : str
        The target to create a shortcut for, it can be a fully qualified
        file path ``/path/to/my_program`` or a simple application name 
        ``my_program``.
    shortcut_name : str=None
        Name of the shortcut without extension (``.lnk`` would be appended if needed).
        If None uses the target filename.
    icon : str=None
        Path to icon file

    Returns
    -------
    tuple (str or None, str or None, str or None)
        (shortcut_name, target_path, shortcut_file_path)
    """
    print('create_desktop_shortcut() %s' % icon)
    if not p.isdir(self.desktop_folder):
        msg = "Desktop folder '{}' not found.".format(self.desktop_folder)
        if self.raise_errors:
            raise ShortcutNoDesktopError(msg)
        elif self.error_log is not None:
            self.error_log.write(msg + '\n')
            return None, None, None
    else:
        return self.create_shortcut(target, self.desktop_folder, shortcut_name, icon)

</t>
<t tx="mhw.20190808131212.37">def create_menu_shortcut(self, target, shortcut_name=None, icon=None):
    """
    Creates a menu shortcut to a target.

    Parameters
    ----------
    target : str
        The target to create a shortcut for, it can be a fully qualified
        file path ``/path/to/my_program`` or a simple application name 
        ``my_program``.
    shortcut_name : str=None
        Name of the shortcut without extension (``.lnk`` would be appended if needed).
        If None uses the target filename.
    icon : str=None
        Path to icon file

    Returns
    -------
    tuple (str or None, str or None, str or None)
        (shortcut_name, target_path, shortcut_file_path)
    """
    if not p.isdir(self.menu_folder):
        msg = "Menu folder '{}' not found.".format(self.menu_folder)
        if self.raise_errors:
            raise ShortcutNoMenuError(msg)
        elif self.error_log is not None:
            self.error_log.write(msg + '\n')
            return None, None, None
    else:
        return self.create_shortcut(target, self.menu_folder, shortcut_name)

</t>
<t tx="mhw.20190808131212.38">@classmethod
def _path_to_name(cls, path):
    """
    Takes three last items from the absolutized path and converts to
    name by replacing everything except `A-Za-z0-9` to `_`
    """
    dirs = '_'.join(p.abspath(path).split(os.sep)[-3:-1])
    return cls._ascii_name('{}__at__{}'.format(p.basename(path), dirs))

</t>
<t tx="mhw.20190808131212.39">@staticmethod
def _ascii_name(name):
    w_unicode_name = re.sub(r'\W', '_', name)
    w_ascii_name = str(w_unicode_name.encode('utf-8'))[1:].strip('"').strip("'").replace('\\', '_')
    return w_ascii_name

</t>
<t tx="mhw.20190808131212.40">def _create_wrapped_shortcut(self, shortcut_name, target_path, shortcut_directory, activate_args=None, icon=None):
    """
    Creates shell script wrapper for shortcut with activation.
    
    Providing activate_args optional argument switches to creation
    of shortcut to terminal with activated environment.
    
    Returns a tuple of (shortcut_name, target_path, shortcut_file_path)
    """
    if activate_args is None:
        activate, env = self.activate_args
        terminals = False
        name = self._path_to_name(target_path)
    else:
        activate, env = activate_args
        terminals = True
        target_path = None
        name = self._ascii_name(shortcut_name)

    wrapper_path = p.join(self.bin_folder_shcut, self.ba('shortcutter__' + name))
    if target_path or terminals:
        def r(path):
            if path is None:
                return ''
            else:
                return path.replace('"', r'\"').replace("'", r"\'")

        def call_batch(path):
            if path is None:
                return ''
            elif os.name == 'nt' and (path.endswith('.bat') or path.endswith('.cmd')):
                return 'call '
            else:
                return ''

        script = (self._ACTIVATE_PROMPT if terminals else self._ACTIVATE).format(
            activate=r(activate) + ('" "' + r(env) if env else ''),
            executable=r(target_path),
            bin=r(p.dirname(activate)),
            call=call_batch(target_path)
        )
        with open(wrapper_path, 'w') as f:
            f.write(script)
            self._make_executable(wrapper_path)
    return self._create_shortcut_file(shortcut_name, wrapper_path, shortcut_directory, icon)

</t>
<t tx="mhw.20190808131212.41">def create_shortcut(self, target, shortcut_directory, shortcut_name=None, icon=None):
    """
    Creates a shortcut to a target.

    Parameters
    ----------
    target : str
        The target to create a shortcut for, it can be a fully qualified
        file path ``/path/to/my_program`` or a simple application name 
        ``my_program``.
    shortcut_directory : str
        The directory path where the shortcut should be created.
    shortcut_name : str=None
        Name of the shortcut without extension (``.lnk`` would be appended if needed).
        If None uses the target filename.

    Returns
    -------
    tuple (str, str, str or None)
        (shortcut_name, target_path, shortcut_file_path)
    """
    print('22:create_shortcut() %s' % icon)
    # Set the target path:
    target_path = self.find_target(target)

    # Check if target is dir or file:
    isdir = False
    if target_path:
        if p.isdir(target_path):
            isdir = True

    if not target_path and not self.exists:
        if target.endswith(os.sep):
            isdir = True
        target_path = p.abspath(target)

    # Set shortcut name:
    if shortcut_name is None:
        if isdir:
            shortcut_name = p.basename(target)
        else:
            # getting the file name and removing the extension:
            shortcut_name = p.splitext(p.basename(target))[0]
    print('44:')
    # Create shortcut function:
    def create():
        if not target_path:
            raise ShortcutError(
                "Target '{}' wasn't found or invalid target/exists ('{}') options combination.".format(target,
                                                                                                       self.exists))

        if isdir:
            print('53: isdir is True')
            return self._create_shortcut_to_dir(shortcut_name, target_path, shortcut_directory, icon)

        elif self.activate:
            activate, env = self.activate_args
            if activate:
                print('59:{},{},{},{}'.format(shortcut_name, target_path, shortcut_directory, icon))
                return self._create_wrapped_shortcut(shortcut_name, target_path, shortcut_directory, icon)

            elif (not activate) and env:
                raise ShortcutError('Shortcutter failed to find conda root (or activate script there). ' +
                                    'It searched in `../../` assuming default env location ' +
                                    '(`../` should have `envs` basename). ' +
                                    'Checked `CONDA_ROOT` environment variable. ' +
                                    'Searched `conda` executable in the PATH.')
        # Use simple shortcuts if self.activate=False or we are installing to common python installation:
        return self._create_shortcut_file(shortcut_name, target_path, shortcut_directory, icon)
    print('70:')
    ret = self._safe_create(create)
    print('ret: {}'.format(ret))
    print('//73:create_shortcut() %s' % icon)    
    return ret if (ret != 'error') else (shortcut_name, target_path, None)

</t>
<t tx="mhw.20190808131212.42">def _safe_create(self, create):
    """
    Switches shortcuts creation function error modes.

    :param create:
        function to call (without arguments)
    """
    print('_safe_create()')
    if self.raise_errors:
        ret = create()
    else:
        try:
            ret = create()
        except Exception:
            ret = 'error'
            if self.error_log is not None:
                self.error_log.write(''.join(traceback.format_exc()))
    return ret

</t>
<t tx="mhw.20190808131212.43">def create_shortcut_to_env_terminal(self, shortcut_name=None, shortcut_directory=None, desktop=True, menu=True):
    """
    Creates shortcuts for console (terminal) that
    has already activated the environment we are installing to
    (plus shortcut to root environment in case of conda).

    Parameters
    ----------
    shortcut_name : str=None
        Name of the shortcut without extension (``.lnk`` would be appended if needed).
        If None uses the target filename.
    shortcut_directory : str=None
        The directory path where the shortcuts should be created.
    desktop : bool=True
        Whether to create shortcuts on the desktop.
    menu : bool=True
        Whether to create shortcuts in the menu.

    Returns
    -------
    bool
        True if all operations were successful, False otherwise.
    """
    activate, env = self.activate_args
    if not activate:
        return
    if not shortcut_name:
        shortcut_name = 'Terminal at '

    ret = []
    for check, path, pref in [(desktop, self.desktop_folder, 'Desktop folder'),
                              (menu, self.menu_folder, 'Menu folder'),
                              (shortcut_directory is not None, shortcut_directory, 'Directory')]:
        if check:
            if not p.isdir(path):
                msg = "{} '{}' not found.".format(pref, path)
                if self.raise_errors:
                    raise ShortcutNoDesktopError(msg)
                elif self.error_log is not None:
                    self.error_log.write(msg + '\n')
                    ret.append('error')
            else:
                name = shortcut_name + p.basename(p.dirname(p.dirname(activate)))
                ret.append(self._safe_create(
                    lambda: self._create_wrapped_shortcut(name, None, path, (activate, None))
                ))
                if env:
                    name = shortcut_name + p.basename(env)
                    ret.append(self._safe_create(
                        lambda: self._create_wrapped_shortcut(name, None, path, (activate, env))
                    ))
    return False if ('error' in ret) else True

# should be overridden
</t>
<t tx="mhw.20190808131212.44">def _create_shortcut_to_dir(self, shortcut_name, target_path, shortcut_directory):
    raise ShortcutError("_create_shortcut_to_dir needs overriding")

# should be overridden
</t>
<t tx="mhw.20190808131212.45">def _create_shortcut_file(self, shortcut_name, target_path, shortcut_directory):
    raise ShortcutError("_create_shortcut_file needs overriding")

</t>
<t tx="mhw.20190808131212.46">def makedirs(self, *args):
    """
    Recursively creates dirs if they don't exist.
    Utilizes ``self.raise_errors`` and ``self.error_log``.
    
    Parameters
    ----------
    \*args : str
        Multiple paths (str) for folders to create.

    Returns
    -------
    bool
        True on success False of failure.
    """
    ret = []
    for path in args:
        if not p.isdir(path):
            ret.append(self._safe_create(lambda: os.makedirs(path)))

    return False if ('error' in ret) else True

</t>
<t tx="mhw.20190808131212.47">def find_target(self, target):
    """
    Finds a file path for a target application.
    Single-worded targets like ``'app'`` are always searched in the PATH.
    You should prepend ``./app`` to tell that the file is in the CWD.

    Parameters
    ----------
    target : str
        The target to find, it can be a fully qualified
        file path ``/path/to/my_program`` or a simple application name 
        ``my_program``.

    Returns
    -------
    str or None
        Returns a single target file path or ``None`` if a path can't be found.
    """
    if target:
        if p.basename(target) == target:
            targets = self.search_for_target(target)
            if len(targets) &gt; 0:
                return p.abspath(targets[0])
            else:
                return None
        elif p.isfile(target) or p.isdir(target):
            return p.abspath(target)
    return None

</t>
<t tx="mhw.20190808131212.48">def search_for_target(self, target):
    """
    Searches for a target application.

    Parameters
    ----------
    target : str
        The target to find.

    Returns
    -------
    list(str)
        Returns a list of potential target file paths, it no paths are found an empty list is returned.
    """
    # potential list of app paths
    target_paths = []

    # create list of potential directories
    paths = self._get_paths()

    # loop through each folder
    for path in paths:
        if p.exists(path):
            if p.isdir(path):
                # get files in directory
                for file_name in os.listdir(path):
                    file_path = p.join(path, file_name)
                    if p.isfile(file_path):
                        if self._is_file_the_target(target, file_name, file_path):
                            target_paths.append(file_path)
            else:
                # its not a directory, is it the app we are looking for?
                pass

    return target_paths

# needs overriding
</t>
<t tx="mhw.20190808131212.49">def _is_file_the_target(self, target, file_name, file_path):
    raise ShortcutError("_is_file_the_target needs overriding")

# needs overriding
</t>
<t tx="mhw.20190808131212.50">@staticmethod
def _get_paths():
    raise ShortcutError("_get_paths needs overriding")
</t>
<t tx="mhw.20190808135317.35">def _create_shortcut_file(self, shortcut_name, target_path, shortcut_directory):
    """
    Creates a Linux shortcut file to folder.
    """
    return self._create_shortcut_linux(shortcut_name, target_path, shortcut_directory,
                                       '[Desktop Entry]\n' +
                                       'Name={}\n'.format(shortcut_name) +
                                       'Type=Application\n' +
                                       'Exec="{}" %F\n'.format(target_path) +
                                       'Terminal=true\n')

</t>
<t tx="mhw.20190808135317.45">def _create_shortcut_file(self, shortcut_name, target_path, shortcut_directory):
    """
    Creates a MacOS app which opens an executable via the terminal
    """
    return create_shortcut(shortcut_name, target_path, shortcut_directory,
                           'tell application "Terminal"\n' +
                           'activate\n' +
                           'do script "{}"\n'.format(target_path) +
                           'end tell\n')
</t>
<t tx="mhw.20190808135317.46">import sys
import site
import os
from os import path as p

# import win32com
# this often fails due to unable to find DLLs
# so dynamically change the path if required
try:
    import win32com
except ImportError as e:
    if "DLL load failed:" in str(e):
        path = p.join(p.split(sys.executable)[0], "Lib", "site-packages", "pywin32_system32")
        os.environ["PATH"] = os.environ["PATH"] + ";" + path
        try:
            import win32com
        except ImportError as ee:
            dll = os.listdir(path)
            dll = [p.join(path, _) for _ in dll if "dll" in _]
            raise ImportError("{}\n Failed to import win32com, due to missing DLL:\n".format(ee) + "\n".join(dll))
    else:
        raise e

from win32com.client import Dispatch
from .base import ShortCutter

shell = Dispatch('WScript.Shell')

ACTIVATE = r"""@echo off
set PYTHONNOUSERSITE=1
call "{activate}"
{call}"{executable}" %*
call "{bin}\deactivate.bat"
"""

ACTIVATE_PROMPT = """@echo off
set "PATH={bin};%PATH%"
set PYTHONNOUSERSITE=1
call "{activate}"
set "u=chcp 65001 &amp;&amp; set PYTHONIOENCODING=utf-8"
set "a=chcp 1252 &amp;&amp; set PYTHONIOENCODING="
set "b=set LANG=C.UTF-8 &amp;&amp; set PYTHONIOENCODING=utf-8 &amp;&amp; "%PROGRAMFILES%\Git\git-bash.exe""
cd /d %USERPROFILE%
cmd /k
"""

FOLDER_SHORTCUT = r"""@echo off
if exist "{path}\" (
    cd /d "{path}"
    start .
) else (
    echo Folder doesn't exist: "{path}"
    pause
)
"""


</t>
<t tx="mhw.20190808135317.47">class ShortCutterWindows(ShortCutter):
    @others
</t>
<t tx="mhw.20190808135317.48">def _set_win_vars(self):
    self._executable_file_extensions = [ext.upper() for ext in os.environ['PATHEXT'].split(os.pathsep)]

</t>
<t tx="mhw.20190808135317.49">@staticmethod
def _get_desktop_folder():
    return shell.SpecialFolders("Desktop")

</t>
<t tx="mhw.20190808135317.50">@staticmethod
def _get_menu_folder():
    return shell.SpecialFolders("Programs")

</t>
<t tx="mhw.20190808135317.51">@staticmethod
def _get_bin_folder_pyexe():
    return p.join(sys.prefix, "Scripts")

</t>
<t tx="mhw.20190808135317.52">@staticmethod
def _get_activate_wrapper_templates():
    return ACTIVATE, ACTIVATE_PROMPT

</t>
<t tx="mhw.20190808135317.53">@staticmethod
def _make_executable(file_path):
    pass

</t>
<t tx="mhw.20190808135317.54">def _create_shortcut_to_dir(self, shortcut_name, target_path, shortcut_directory):
    return self._create_shortcut_win(shortcut_name, target_path, shortcut_directory, icon, True)

</t>
<t tx="mhw.20190808135317.55">def _create_shortcut_file(self, shortcut_name, target_path, shortcut_directory, icon):
    return self._create_shortcut_win(shortcut_name, target_path, shortcut_directory, icon)

</t>
<t tx="mhw.20190808135317.56">def _create_shortcut_win(self, shortcut_name, target_path, shortcut_directory, folder=False, icon=None):
    """
    Creates a Windows shortcut file.

    Returns tuple (shortcut_name, target_path, shortcut_file_path)
    """
    print('_create_shortcut_win(): %s' % icon)
    if not folder:
        shortcut_target_path = target_path
        working_directory = p.dirname(target_path)
        ext = p.splitext(target_path)[1].upper()
        if not icon:
            if ext in self._executable_file_extensions:
                icon = r'%SystemRoot%\System32\imageres.dll,11'
    
    elif not p.isdir(target_path):
        # create a bat script that opens the folder:
        
        wrapper_path = p.join(self.bin_folder_shcut, self.ba('shortcutter__dir__' + self._path_to_name(target_path)))
        with open(wrapper_path, 'w') as f:
            f.write(FOLDER_SHORTCUT.format(path=target_path))
        shortcut_target_path = wrapper_path
        working_directory = self.bin_folder_shcut
        icon = r'%SystemRoot%\explorer.exe,0'

    else:
        shortcut_target_path = target_path
        working_directory = target_path

    shortcut_file_path = p.join(shortcut_directory, shortcut_name + ".lnk")
    shortcut = shell.CreateShortCut(shortcut_file_path)
    shortcut.Targetpath = shortcut_target_path
    shortcut.WorkingDirectory = working_directory
    shortcut.Description = "Shortcut to" + p.basename(target_path)
    if icon:
        shortcut.IconLocation = icon
        print('//_create_shortcut_win %s' % icon)
    shortcut.save()

    return shortcut_name, target_path, shortcut_file_path
</t>
<t tx="mhw.20190808135317.57">def _is_file_the_target(self, target, file_name, file_path):
    match = False
    # does the target have an extension?
    target_ext = p.splitext(target)[1]
    # if so, do a direct match
    if target_ext:
        if file_name.lower() == target.lower():
            match = True
    # no extension, compare the target to the file_name for each executable file extension
    else:
        for extension in self._executable_file_extensions:
            if file_name.lower() == (target + extension).lower():
                match = True
    return match

</t>
<t tx="mhw.20190808135317.58">@staticmethod
def _get_paths():
    """
    Gets paths from the PATH environment variable and 
    prepends `&lt;Python&gt;`, `&lt;Python&gt;\Scripts`, `&lt;Python&gt;\Library\bin` directories.

    Returns a list of paths.
    """
    root = p.dirname(sys.executable)
    user_root = p.dirname(site.USER_SITE)
    return [root,
            p.join(root, 'Scripts'),
            p.join(root, 'Library', 'bin')
           ] + os.environ['PATH'].split(os.pathsep) + [p.join(user_root, 'Scripts')]
</t>
<t tx="mhw.20190808140641.1">@nosearch
@language python

# flattened, ignore-case, head, body

# found 3 nodes</t>
<t tx="mhw.20190808141042.1">@nosearch
@language python

# flattened, ignore-case, head, body

# found 6 nodes</t>
</tnodes>
</leo_file>
