<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="mhw.20190808084549.2"><vh>Shortcutter</vh>
<v t="mhw.20190808085013.1"><vh>@path ../shortcutter</vh>
<v t="mhw.20190808092452.15"><vh>/conda-forge/</vh></v>
<v t="mhw.20190808092452.14"><vh>/docs/</vh></v>
<v t="mhw.20190808092452.12"><vh>/shortcutter/</vh>
<v t="mhw.20190808085024.7"><vh>@auto __init__.py</vh></v>
<v t="mhw.20190808085024.6"><vh>@auto _version.py</vh></v>
<v t="mhw.20190808085024.5"><vh>@clean base.py</vh>
<v t="mhw.20190808131212.23"><vh>Declarations (base.py)</vh></v>
<v t="mhw.20190808131212.24"><vh>class ShortCutter(object)</vh>
<v t="mhw.20190808131212.25"><vh>ShortCutter(object).__init__</vh></v>
<v t="mhw.20190808131212.26"><vh>ShortCutter(object)._set_win_vars</vh></v>
<v t="mhw.20190808131212.27"><vh>ShortCutter(object)._get_desktop_folder</vh></v>
<v t="mhw.20190808131212.28"><vh>ShortCutter(object)._get_menu_folder</vh></v>
<v t="mhw.20190808131212.29"><vh>ShortCutter(object)._get_bin_folder_pyexe</vh></v>
<v t="mhw.20190808131212.30"><vh>ShortCutter(object)._get_activate_wrapper_templates</vh></v>
<v t="mhw.20190808131212.31"><vh>ShortCutter(object)._make_executable</vh></v>
<v t="mhw.20190808131212.32"><vh>ShortCutter(object).exe</vh></v>
<v t="mhw.20190808131212.33"><vh>ShortCutter(object).ba</vh></v>
<v t="mhw.20190808131212.34"><vh>ShortCutter(object)._get_activate_args</vh></v>
<v t="mhw.20190808131212.35"><vh>ShortCutter(object)._check_if_conda_root</vh></v>
<v t="mhw.20190808131212.36"><vh>ShortCutter(object).create_desktop_shortcut</vh></v>
<v t="mhw.20190808131212.37"><vh>ShortCutter(object).create_menu_shortcut</vh></v>
<v t="mhw.20190808131212.38"><vh>ShortCutter(object)._path_to_name</vh></v>
<v t="mhw.20190808131212.39"><vh>ShortCutter(object)._ascii_name</vh></v>
<v t="mhw.20190808131212.40"><vh>ShortCutter(object)._create_wrapped_shortcut</vh></v>
<v t="mhw.20190808131212.41"><vh>ShortCutter(object).create_shortcut</vh></v>
<v t="mhw.20190808131212.42"><vh>ShortCutter(object)._safe_create</vh></v>
<v t="mhw.20190808131212.43"><vh>ShortCutter(object).create_shortcut_to_env_terminal</vh></v>
<v t="mhw.20190808131212.44"><vh>ShortCutter(object)._create_shortcut_to_dir</vh></v>
<v t="mhw.20190808131212.45"><vh>ShortCutter(object)._create_shortcut_file</vh></v>
<v t="mhw.20190808131212.46"><vh>ShortCutter(object).makedirs</vh></v>
<v t="mhw.20190808131212.47"><vh>ShortCutter(object).find_target</vh></v>
<v t="mhw.20190808131212.48"><vh>ShortCutter(object).search_for_target</vh></v>
<v t="mhw.20190808131212.49"><vh>ShortCutter(object)._is_file_the_target</vh></v>
<v t="mhw.20190808131212.50"><vh>ShortCutter(object)._get_paths</vh></v>
</v>
</v>
<v t="mhw.20190808085024.4"><vh>@auto exception.py</vh></v>
<v t="mhw.20190808085024.3"><vh>@auto linux.py</vh></v>
<v t="mhw.20190808085024.2"><vh>@auto macos.py</vh></v>
<v t="mhw.20190808085024.1"><vh>@clean windows.py</vh>
<v t="mhw.20190808135317.46"><vh>Declarations (windows.py)</vh></v>
<v t="mhw.20190808135317.47"><vh>class ShortCutterWindows(ShortCutter)</vh>
<v t="mhw.20190808135317.48"><vh>ShortCutterWindows(ShortCutter)._set_win_vars</vh></v>
<v t="mhw.20190808135317.49"><vh>ShortCutterWindows(ShortCutter)._get_desktop_folder</vh></v>
<v t="mhw.20190808135317.50"><vh>ShortCutterWindows(ShortCutter)._get_menu_folder</vh></v>
<v t="mhw.20190808135317.51"><vh>ShortCutterWindows(ShortCutter)._get_bin_folder_pyexe</vh></v>
<v t="mhw.20190808135317.52"><vh>ShortCutterWindows(ShortCutter)._get_activate_wrapper_templates</vh></v>
<v t="mhw.20190808135317.53"><vh>ShortCutterWindows(ShortCutter)._make_executable</vh></v>
<v t="mhw.20190808135317.54"><vh>ShortCutterWindows(ShortCutter)._create_shortcut_to_dir</vh></v>
<v t="mhw.20190808135317.55"><vh>ShortCutterWindows(ShortCutter)._create_shortcut_file</vh></v>
<v t="mhw.20190808135317.56"><vh>ShortCutterWindows(ShortCutter)._create_shortcut_win</vh></v>
<v t="mhw.20190808135317.57"><vh>ShortCutterWindows(ShortCutter)._is_file_the_target</vh></v>
<v t="mhw.20190808135317.58"><vh>ShortCutterWindows(ShortCutter)._get_paths</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="mhw.20190808090216.1"><vh>modified</vh>
<v t="mhw.20190808131212.36"></v>
<v t="mhw.20190808131212.41"></v>
<v t="mhw.20190808135317.55"></v>
<v t="mhw.20190808135317.56"></v>
<v t="mhw.20190808131212.37"></v>
</v>
<v t="mhw.20190808140641.1"><vh>Found:_create_shortcut_win</vh>
<v t="mhw.20190808135317.55"></v>
<v t="mhw.20190808135317.54"></v>
<v t="mhw.20190808135317.56"></v>
</v>
<v t="mhw.20190808141042.1"><vh>Found:_create_shortcut_file</vh>
<v t="mhw.20190808131212.45"></v>
<v t="mhw.20190808131212.40"></v>
<v t="mhw.20190808131212.41"></v>
<v t="mhw.20190808135317.35"><vh>ShortCutterLinux(ShortCutter)._create_shortcut_file</vh></v>
<v t="mhw.20190808135317.45"><vh>ShortCutterMacOS(ShortCutterLinux)._create_shortcut_file</vh></v>
<v t="mhw.20190808135317.55"></v>
</v>
</vnodes>
<tnodes>
<t tx="mhw.20190808084549.2">Easy cross-platform creation of shortcuts supporting virtual and Anaconda environments

Upstream: https://github.com/kiwi0fruit/shortcutter
My fork: https://github.com/maphew/shortcutter.git


@path ../shortcutter
</t>
<t tx="mhw.20190808085013.1"></t>
<t tx="mhw.20190808085024.1">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190808085024.5">@others
@language python
@tabwidth -4
</t>
<t tx="mhw.20190808090216.1">@language python
@tabwidth -4
</t>
<t tx="mhw.20190808092452.12">@path shortcutter</t>
<t tx="mhw.20190808092452.14">@path docs</t>
<t tx="mhw.20190808092452.15">@path conda-forge</t>
<t tx="mhw.20190808131212.23">import os
import sys
from os import path as p
from .exception import ShortcutError, ShortcutNoDesktopError, ShortcutNoMenuError
import re
import traceback


</t>
<t tx="mhw.20190808131212.24">class ShortCutter(object):
    """
    Creates applicaton shortcuts for Windows, MacOS and Linux operating systems.

    To create desktop and menu shortcuts to ``python``::

        from shortcutter import ShortCutter
        s = ShortCutter()
        s.create_desktop_shortcut("python")
        s.create_menu_shortcut("python")

    Attributes:
    -----------
    raise_errors : bool=False
        Whether to raise exceptions or skip errors and continue.
    error_log : object=None
        File object where to write errors when ``raise_errors=False``.
        Default is None - do not write errors.
        Can also be ``sys.stderr`` or ``io.StringIO()``.
    desktop_folder : str
        Directory used when creating desktop shortcuts.
    menu_folder : str
        Directory used when creating menu shortcuts.
    bin_folder_pyexe : str
        ``Scripts`` or ``bin`` dir path. Simply closest to python executable path.
    bin_folder_shcut : str or None
        ``Scripts`` or ``bin`` dir path where shortcutter executable was installed.
    local_root : str
        Root directory path of the current python environment / installation.
        Derived from python executable path.
    activate : bool=True
        Whether to create shortcuts that automatically activate
        conda environment / virtual environment.
    exists : bool=True
        Whether the target should exist or not.
        If not then add ``/`` (``\\`` on Windows) at the end of the path to get dir shortcut.
    activate_args : tuple (str or None, str or None)
        First is the activate script full path (or None if it's wasn't found) - conda's or venv's.
        Second is the env argument of the activate script (or None if not needed).
    """

    @others
</t>
<t tx="mhw.20190808131212.25">def __init__(self, raise_errors=False, error_log=None, activate=True, exists=True):
    """
    Creates ShortCutter.

    Parameters
    ----------
    raise_errors : bool=False
        Whether to raise exceptions or skip errors and continue.
    error_log : object=None
        File object where to write errors when ``raise_errors=False``.
        Default is None - do not write errors.
        Can also be ``sys.stderr`` or ``io.StringIO()``.
    activate : bool=True
        Whether to create shortcuts that automatically activate
        conda environment / virtual environment.
    exists : bool=True
        Whether the target should exist or not.
        If not then add ``/`` (``\\`` on Windows) at the end of the path to get dir shortcut.
    """
    self._set_win_vars()  # important on Windows

    self.raise_errors = raise_errors
    self.error_log = error_log
    self.activate = activate
    self.exists = exists
    self.desktop_folder = self._get_desktop_folder()
    self.menu_folder = self._get_menu_folder()
    self.bin_folder_pyexe = self._get_bin_folder_pyexe()
    shortcutter = self.find_target('shortcutter')
    self.bin_folder_shcut = p.dirname(shortcutter) if shortcutter else self.bin_folder_pyexe
    self.local_root = sys.prefix
    self._ACTIVATE, self._ACTIVATE_PROMPT = self._get_activate_wrapper_templates()

    self.activate_args = self._get_activate_args()  # should be run the last

# might be overridden if needed
</t>
<t tx="mhw.20190808131212.26">def _set_win_vars(self):
    pass

# should be overridden
</t>
<t tx="mhw.20190808131212.27">@staticmethod
def _get_desktop_folder():
    raise ShortcutError("_get_desktop_folder needs overriding")

# should be overridden
</t>
<t tx="mhw.20190808131212.28">@staticmethod
def _get_menu_folder():
    raise ShortcutError("_get_menu_folder needs overriding")

# should be overridden
</t>
<t tx="mhw.20190808131212.29">@staticmethod
def _get_bin_folder_pyexe():
    raise ShortcutError("_get_bin_folder_pyexe needs overriding")

# should be overridden
</t>
<t tx="mhw.20190808131212.30">@staticmethod
def _get_activate_wrapper_templates():
    raise ShortcutError("_get_activate_wrapper_templates needs overriding")

# should be overridden
</t>
<t tx="mhw.20190808131212.31">@staticmethod
def _make_executable(file_path):
    raise ShortcutError("_make_executable needs overriding")

</t>
<t tx="mhw.20190808131212.32">def exe(self, app_name):
    """
    Returns platform independent executable name:

    * app &gt; app (on Unix)
    * app &gt; app.exe (on Windows)
    """
    if os.name == 'nt':
        return app_name + '.exe'
    else:
        return app_name

</t>
<t tx="mhw.20190808131212.33">def ba(self, script_name):
    """
    Returns platform independent shell script (bash/batch) name:

    * run &gt; run (on Unix)
    * run &gt; run.bat (on Windows)
    """
    if os.name == 'nt':
        return script_name + '.bat'
    else:
        return script_name

</t>
<t tx="mhw.20190808131212.34">def _get_activate_args(self):
    """
    Returns tuple: (str or None, str or None).

    First is the activate script full path (or None if it's wasn't found) - conda's or venv's.

    Second is the env argument of the activate script (or None if not needed).
    """
    if p.isdir(p.join(self.local_root, 'conda-meta')):
        # check if we are installing to conda root:
        activate = self._check_if_conda_root(self.local_root)
        if activate:
            return activate, None

        # check if we are installing to default conda env location:
        #   `&lt;conda_root&gt;/envs/&lt;local_root_basename&gt;`
        ddot = p.dirname(self.local_root)
        activate = self._check_if_conda_root(p.dirname(ddot))
        if (p.basename(ddot) == 'envs') and activate: 
            return activate, p.basename(self.local_root)

        # check if we are running pip via `conda env create -f env.yaml`
        #   or user specified `CONDA_ROOT` env var himself:
        conda_root = os.environ.get('CONDA_ROOT')
        activate = self._check_if_conda_root(conda_root)
        if activate:
            if p.isabs(conda_root):
                return activate, self.local_root

        # check if there is conda in the PATH:
        conda = self.find_target('conda')
        if conda is not None:
            conda_root = p.dirname(p.dirname(conda))
            activate = self._check_if_conda_root(conda_root)
            if activate:
                return activate, self.local_root

        return None, self.local_root
    else:
        # check if we are installing to venv:
        activate = p.join(self.bin_folder_pyexe, self.ba('activate'))
        if p.isfile(activate):
            return activate, None

    return None, None
 
</t>
<t tx="mhw.20190808131212.35">def _check_if_conda_root(self, path):
    """
    Checks if provided path is conda root. It should have
    conda-meta folder, conda executable, activate shell script.

    Returns path to conda activate script or None.
    """
    if path is not None:
        if p.isdir(p.join(path, 'conda-meta')):
            conda = p.join(path,
                           p.basename(self.bin_folder_pyexe),
                           self.exe('conda'))
            # check if the file executable:
            if p.isfile(conda) and os.access(conda, os.X_OK):
                activate = p.join(p.dirname(conda), self.ba('activate'))
                if p.isfile(activate):
                    return p.abspath(activate)
    return None

</t>
<t tx="mhw.20190808131212.36">def create_desktop_shortcut(self, target, shortcut_name=None, icon=None):
    """
    Creates a desktop shortcut to a target.

    Parameters
    ----------
    target : str
        The target to create a shortcut for, it can be a fully qualified
        file path ``/path/to/my_program`` or a simple application name 
        ``my_program``.
    shortcut_name : str=None
        Name of the shortcut without extension (``.lnk`` would be appended if needed).
        If None uses the target filename.
    icon : str=None
        Path to icon file

    Returns
    -------
    tuple (str or None, str or None, str or None)
        (shortcut_name, target_path, shortcut_file_path, icon_file_path)
    """
    print('create_desktop_shortcut() %s' % icon)
    if not p.isdir(self.desktop_folder):
        msg = "Desktop folder '{}' not found.".format(self.desktop_folder)
        if self.raise_errors:
            raise ShortcutNoDesktopError(msg)
        elif self.error_log is not None:
            self.error_log.write(msg + '\n')
            return None, None, None, None
    else:
        return self.create_shortcut(target, self.desktop_folder, shortcut_name, icon)

</t>
<t tx="mhw.20190808131212.37">def create_menu_shortcut(self, target, shortcut_name=None, icon=None):
    """
    Creates a menu shortcut to a target.

    Parameters
    ----------
    target : str
        The target to create a shortcut for, it can be a fully qualified
        file path ``/path/to/my_program`` or a simple application name 
        ``my_program``.
    shortcut_name : str=None
        Name of the shortcut without extension (``.lnk`` would be appended if needed).
        If None uses the target filename.
    icon : str=None
        Path to icon file

    Returns
    -------
    tuple (str or None, str or None, str or None)
        (shortcut_name, target_path, shortcut_file_path)
    """
    if not p.isdir(self.menu_folder):
        msg = "Menu folder '{}' not found.".format(self.menu_folder)
        if self.raise_errors:
            raise ShortcutNoMenuError(msg)
        elif self.error_log is not None:
            self.error_log.write(msg + '\n')
            return None, None, None
    else:
        return self.create_shortcut(target, self.menu_folder, shortcut_name)

</t>
<t tx="mhw.20190808131212.38">@classmethod
def _path_to_name(cls, path):
    """
    Takes three last items from the absolutized path and converts to
    name by replacing everything except `A-Za-z0-9` to `_`
    """
    dirs = '_'.join(p.abspath(path).split(os.sep)[-3:-1])
    return cls._ascii_name('{}__at__{}'.format(p.basename(path), dirs))

</t>
<t tx="mhw.20190808131212.39">@staticmethod
def _ascii_name(name):
    w_unicode_name = re.sub(r'\W', '_', name)
    w_ascii_name = str(w_unicode_name.encode('utf-8'))[1:].strip('"').strip("'").replace('\\', '_')
    return w_ascii_name

</t>
<t tx="mhw.20190808131212.40">def _create_wrapped_shortcut(self, shortcut_name, target_path, shortcut_directory, activate_args=None, icon=None):
    """
    Creates shell script wrapper for shortcut with activation.
    
    Providing activate_args optional argument switches to creation
    of shortcut to terminal with activated environment.
    
    Returns a tuple of (shortcut_name, target_path, shortcut_file_path)
    """
    if activate_args is None:
        activate, env = self.activate_args
        terminals = False
        name = self._path_to_name(target_path)
    else:
        activate, env = activate_args
        terminals = True
        target_path = None
        name = self._ascii_name(shortcut_name)

    wrapper_path = p.join(self.bin_folder_shcut, self.ba('shortcutter__' + name))
    if target_path or terminals:
        def r(path):
            if path is None:
                return ''
            else:
                return path.replace('"', r'\"').replace("'", r"\'")

        def call_batch(path):
            if path is None:
                return ''
            elif os.name == 'nt' and (path.endswith('.bat') or path.endswith('.cmd')):
                return 'call '
            else:
                return ''

        script = (self._ACTIVATE_PROMPT if terminals else self._ACTIVATE).format(
            activate=r(activate) + ('" "' + r(env) if env else ''),
            executable=r(target_path),
            bin=r(p.dirname(activate)),
            call=call_batch(target_path)
        )
        with open(wrapper_path, 'w') as f:
            f.write(script)
            self._make_executable(wrapper_path)
    return self._create_shortcut_file(shortcut_name, wrapper_path, shortcut_directory, icon)

</t>
<t tx="mhw.20190808131212.41">def create_shortcut(self, target, shortcut_directory, shortcut_name=None, icon=None):
    """
    Creates a shortcut to a target.

    Parameters
    ----------
    target : str
        The target to create a shortcut for, it can be a fully qualified
        file path ``/path/to/my_program`` or a simple application name 
        ``my_program``.
    shortcut_directory : str
        The directory path where the shortcut should be created.
    shortcut_name : str=None
        Name of the shortcut without extension (``.lnk`` would be appended if needed).
        If None uses the target filename.

    Returns
    -------
    tuple (str, str, str or None)
        (shortcut_name, target_path, shortcut_file_path)
    """
    print('create_shortcut() %s' % icon)
    # Set the target path:
    target_path = self.find_target(target)

    # Check if target is dir or file:
    isdir = False
    if target_path:
        if p.isdir(target_path):
            isdir = True

    if not target_path and not self.exists:
        if target.endswith(os.sep):
            isdir = True
        target_path = p.abspath(target)

    # Set shortcut name:
    if shortcut_name is None:
        if isdir:
            shortcut_name = p.basename(target)
        else:
            # getting the file name and removing the extension:
            shortcut_name = p.splitext(p.basename(target))[0]

    # Create shortcut function:
    def create():
        if not target_path:
            raise ShortcutError(
                "Target '{}' wasn't found or invalid target/exists ('{}') options combination.".format(target,
                                                                                                       self.exists))

        if isdir:
            return self._create_shortcut_to_dir(shortcut_name, target_path, shortcut_directory, icon)

        elif self.activate:
            activate, env = self.activate_args
            if activate:
                return self._create_wrapped_shortcut(shortcut_name, target_path, shortcut_directory, icon)

            elif (not activate) and env:
                raise ShortcutError('Shortcutter failed to find conda root (or activate script there). ' +
                                    'It searched in `../../` assuming default env location ' +
                                    '(`../` should have `envs` basename). ' +
                                    'Checked `CONDA_ROOT` environment variable. ' +
                                    'Searched `conda` executable in the PATH.')
        # Use simple shortcuts if self.activate=False or we are installing to common python installation:
        return self._create_shortcut_file(shortcut_name, target_path, shortcut_directory, icon)

    ret = self._safe_create(create)
    print('//create_shortcut() %s' % icon)    
    return ret if (ret != 'error') else (shortcut_name, target_path, None)

</t>
<t tx="mhw.20190808131212.42">def _safe_create(self, create):
    """
    Switches shortcuts creation function error modes.

    :param create:
        function to call (without arguments)
    """
    if self.raise_errors:
        ret = create()
    else:
        try:
            ret = create()
        except Exception:
            ret = 'error'
            if self.error_log is not None:
                self.error_log.write(''.join(traceback.format_exc()))
    return ret

</t>
<t tx="mhw.20190808131212.43">def create_shortcut_to_env_terminal(self, shortcut_name=None, shortcut_directory=None, desktop=True, menu=True):
    """
    Creates shortcuts for console (terminal) that
    has already activated the environment we are installing to
    (plus shortcut to root environment in case of conda).

    Parameters
    ----------
    shortcut_name : str=None
        Name of the shortcut without extension (``.lnk`` would be appended if needed).
        If None uses the target filename.
    shortcut_directory : str=None
        The directory path where the shortcuts should be created.
    desktop : bool=True
        Whether to create shortcuts on the desktop.
    menu : bool=True
        Whether to create shortcuts in the menu.

    Returns
    -------
    bool
        True if all operations were successful, False otherwise.
    """
    activate, env = self.activate_args
    if not activate:
        return
    if not shortcut_name:
        shortcut_name = 'Terminal at '

    ret = []
    for check, path, pref in [(desktop, self.desktop_folder, 'Desktop folder'),
                              (menu, self.menu_folder, 'Menu folder'),
                              (shortcut_directory is not None, shortcut_directory, 'Directory')]:
        if check:
            if not p.isdir(path):
                msg = "{} '{}' not found.".format(pref, path)
                if self.raise_errors:
                    raise ShortcutNoDesktopError(msg)
                elif self.error_log is not None:
                    self.error_log.write(msg + '\n')
                    ret.append('error')
            else:
                name = shortcut_name + p.basename(p.dirname(p.dirname(activate)))
                ret.append(self._safe_create(
                    lambda: self._create_wrapped_shortcut(name, None, path, (activate, None))
                ))
                if env:
                    name = shortcut_name + p.basename(env)
                    ret.append(self._safe_create(
                        lambda: self._create_wrapped_shortcut(name, None, path, (activate, env))
                    ))
    return False if ('error' in ret) else True

# should be overridden
</t>
<t tx="mhw.20190808131212.44">def _create_shortcut_to_dir(self, shortcut_name, target_path, shortcut_directory):
    raise ShortcutError("_create_shortcut_to_dir needs overriding")

# should be overridden
</t>
<t tx="mhw.20190808131212.45">def _create_shortcut_file(self, shortcut_name, target_path, shortcut_directory):
    raise ShortcutError("_create_shortcut_file needs overriding")

</t>
<t tx="mhw.20190808131212.46">def makedirs(self, *args):
    """
    Recursively creates dirs if they don't exist.
    Utilizes ``self.raise_errors`` and ``self.error_log``.
    
    Parameters
    ----------
    \*args : str
        Multiple paths (str) for folders to create.

    Returns
    -------
    bool
        True on success False of failure.
    """
    ret = []
    for path in args:
        if not p.isdir(path):
            ret.append(self._safe_create(lambda: os.makedirs(path)))

    return False if ('error' in ret) else True

</t>
<t tx="mhw.20190808131212.47">def find_target(self, target):
    """
    Finds a file path for a target application.
    Single-worded targets like ``'app'`` are always searched in the PATH.
    You should prepend ``./app`` to tell that the file is in the CWD.

    Parameters
    ----------
    target : str
        The target to find, it can be a fully qualified
        file path ``/path/to/my_program`` or a simple application name 
        ``my_program``.

    Returns
    -------
    str or None
        Returns a single target file path or ``None`` if a path can't be found.
    """
    if target:
        if p.basename(target) == target:
            targets = self.search_for_target(target)
            if len(targets) &gt; 0:
                return p.abspath(targets[0])
            else:
                return None
        elif p.isfile(target) or p.isdir(target):
            return p.abspath(target)
    return None

</t>
<t tx="mhw.20190808131212.48">def search_for_target(self, target):
    """
    Searches for a target application.

    Parameters
    ----------
    target : str
        The target to find.

    Returns
    -------
    list(str)
        Returns a list of potential target file paths, it no paths are found an empty list is returned.
    """
    # potential list of app paths
    target_paths = []

    # create list of potential directories
    paths = self._get_paths()

    # loop through each folder
    for path in paths:
        if p.exists(path):
            if p.isdir(path):
                # get files in directory
                for file_name in os.listdir(path):
                    file_path = p.join(path, file_name)
                    if p.isfile(file_path):
                        if self._is_file_the_target(target, file_name, file_path):
                            target_paths.append(file_path)
            else:
                # its not a directory, is it the app we are looking for?
                pass

    return target_paths

# needs overriding
</t>
<t tx="mhw.20190808131212.49">def _is_file_the_target(self, target, file_name, file_path):
    raise ShortcutError("_is_file_the_target needs overriding")

# needs overriding
</t>
<t tx="mhw.20190808131212.50">@staticmethod
def _get_paths():
    raise ShortcutError("_get_paths needs overriding")
</t>
<t tx="mhw.20190808135317.35">def _create_shortcut_file(self, shortcut_name, target_path, shortcut_directory):
    """
    Creates a Linux shortcut file to folder.
    """
    return self._create_shortcut_linux(shortcut_name, target_path, shortcut_directory,
                                       '[Desktop Entry]\n' +
                                       'Name={}\n'.format(shortcut_name) +
                                       'Type=Application\n' +
                                       'Exec="{}" %F\n'.format(target_path) +
                                       'Terminal=true\n')

</t>
<t tx="mhw.20190808135317.45">def _create_shortcut_file(self, shortcut_name, target_path, shortcut_directory):
    """
    Creates a MacOS app which opens an executable via the terminal
    """
    return create_shortcut(shortcut_name, target_path, shortcut_directory,
                           'tell application "Terminal"\n' +
                           'activate\n' +
                           'do script "{}"\n'.format(target_path) +
                           'end tell\n')
</t>
<t tx="mhw.20190808135317.46">import sys
import site
import os
from os import path as p

# import win32com
# this often fails due to unable to find DLLs
# so dynamically change the path if required
try:
    import win32com
except ImportError as e:
    if "DLL load failed:" in str(e):
        path = p.join(p.split(sys.executable)[0], "Lib", "site-packages", "pywin32_system32")
        os.environ["PATH"] = os.environ["PATH"] + ";" + path
        try:
            import win32com
        except ImportError as ee:
            dll = os.listdir(path)
            dll = [p.join(path, _) for _ in dll if "dll" in _]
            raise ImportError("{}\n Failed to import win32com, due to missing DLL:\n".format(ee) + "\n".join(dll))
    else:
        raise e

from win32com.client import Dispatch
from .base import ShortCutter

shell = Dispatch('WScript.Shell')

ACTIVATE = r"""@echo off
set PYTHONNOUSERSITE=1
call "{activate}"
{call}"{executable}" %*
call "{bin}\deactivate.bat"
"""

ACTIVATE_PROMPT = """@echo off
set "PATH={bin};%PATH%"
set PYTHONNOUSERSITE=1
call "{activate}"
set "u=chcp 65001 &amp;&amp; set PYTHONIOENCODING=utf-8"
set "a=chcp 1252 &amp;&amp; set PYTHONIOENCODING="
set "b=set LANG=C.UTF-8 &amp;&amp; set PYTHONIOENCODING=utf-8 &amp;&amp; "%PROGRAMFILES%\Git\git-bash.exe""
cd /d %USERPROFILE%
cmd /k
"""

FOLDER_SHORTCUT = r"""@echo off
if exist "{path}\" (
    cd /d "{path}"
    start .
) else (
    echo Folder doesn't exist: "{path}"
    pause
)
"""


</t>
<t tx="mhw.20190808135317.47">class ShortCutterWindows(ShortCutter):
    @others
</t>
<t tx="mhw.20190808135317.48">def _set_win_vars(self):
    self._executable_file_extensions = [ext.upper() for ext in os.environ['PATHEXT'].split(os.pathsep)]

</t>
<t tx="mhw.20190808135317.49">@staticmethod
def _get_desktop_folder():
    return shell.SpecialFolders("Desktop")

</t>
<t tx="mhw.20190808135317.50">@staticmethod
def _get_menu_folder():
    return shell.SpecialFolders("Programs")

</t>
<t tx="mhw.20190808135317.51">@staticmethod
def _get_bin_folder_pyexe():
    return p.join(sys.prefix, "Scripts")

</t>
<t tx="mhw.20190808135317.52">@staticmethod
def _get_activate_wrapper_templates():
    return ACTIVATE, ACTIVATE_PROMPT

</t>
<t tx="mhw.20190808135317.53">@staticmethod
def _make_executable(file_path):
    pass

</t>
<t tx="mhw.20190808135317.54">def _create_shortcut_to_dir(self, shortcut_name, target_path, shortcut_directory):
    return self._create_shortcut_win(shortcut_name, target_path, shortcut_directory, icon, True)

</t>
<t tx="mhw.20190808135317.55">def _create_shortcut_file(self, shortcut_name, target_path, shortcut_directory, icon):
    print('_create_shortcut_file(): %s' % icon)
    return self._create_shortcut_win(shortcut_name, target_path, shortcut_directory, icon=icon)

</t>
<t tx="mhw.20190808135317.56">def _create_shortcut_win(self, shortcut_name, target_path, shortcut_directory, folder=False, icon=None):
    """
    Creates a Windows shortcut file.

    Returns tuple (shortcut_name, target_path, shortcut_file_path)
    """
    print(f'_create_shortcut_win(): {self}, {shortcut_name}, {target_path}, {shortcut_directory}, {folder}, {icon}')
    if not folder:
        shortcut_target_path = target_path
        working_directory = p.dirname(target_path)
        ext = p.splitext(target_path)[1].upper()
        if not icon:
            if ext in self._executable_file_extensions:
                icon = r'%SystemRoot%\System32\imageres.dll,11'
    
    elif not p.isdir(target_path):
        # create a bat script that opens the folder:
        
        wrapper_path = p.join(self.bin_folder_shcut, self.ba('shortcutter__dir__' + self._path_to_name(target_path)))
        with open(wrapper_path, 'w') as f:
            f.write(FOLDER_SHORTCUT.format(path=target_path))
        shortcut_target_path = wrapper_path
        working_directory = self.bin_folder_shcut
        icon = r'%SystemRoot%\explorer.exe,0'

    else:
        shortcut_target_path = target_path
        working_directory = target_path

    shortcut_file_path = p.join(shortcut_directory, shortcut_name + ".lnk")
    shortcut = shell.CreateShortCut(shortcut_file_path)
    shortcut.Targetpath = shortcut_target_path
    shortcut.WorkingDirectory = working_directory
    shortcut.Description = "Shortcut to" + p.basename(target_path)
    if icon:
        shortcut.IconLocation = icon
        print('//_create_shortcut_win %s' % icon)
    shortcut.save()

    return shortcut_name, target_path, shortcut_file_path
</t>
<t tx="mhw.20190808135317.57">def _is_file_the_target(self, target, file_name, file_path):
    match = False
    # does the target have an extension?
    target_ext = p.splitext(target)[1]
    # if so, do a direct match
    if target_ext:
        if file_name.lower() == target.lower():
            match = True
    # no extension, compare the target to the file_name for each executable file extension
    else:
        for extension in self._executable_file_extensions:
            if file_name.lower() == (target + extension).lower():
                match = True
    return match

</t>
<t tx="mhw.20190808135317.58">@staticmethod
def _get_paths():
    """
    Gets paths from the PATH environment variable and 
    prepends `&lt;Python&gt;`, `&lt;Python&gt;\Scripts`, `&lt;Python&gt;\Library\bin` directories.

    Returns a list of paths.
    """
    root = p.dirname(sys.executable)
    user_root = p.dirname(site.USER_SITE)
    return [root,
            p.join(root, 'Scripts'),
            p.join(root, 'Library', 'bin')
           ] + os.environ['PATH'].split(os.pathsep) + [p.join(user_root, 'Scripts')]
</t>
<t tx="mhw.20190808140641.1">@nosearch
@language python

# flattened, ignore-case, head, body

# found 3 nodes</t>
<t tx="mhw.20190808141042.1">@nosearch
@language python

# flattened, ignore-case, head, body

# found 6 nodes</t>
</tnodes>
</leo_file>
